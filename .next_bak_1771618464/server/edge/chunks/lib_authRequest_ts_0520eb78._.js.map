{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/esm/server/request/cookies.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/headers.js","turbopack:///[project]/lib/authSession.ts","turbopack:///[project]/lib/authRequest.ts","turbopack:///[project]/node_modules/next/dist/esm/server/request/draft-mode.js"],"sourcesContent":["import { areCookiesMutableInCurrentPhase, RequestCookiesAdapter } from '../web/spec-extension/adapters/request-cookies';\nimport { RequestCookies } from '../web/spec-extension/cookies';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { throwForMissingRequestStore, workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { delayUntilRuntimeStage, postponeWithTracking, throwToInterruptStaticGeneration, trackDynamicDataInDynamicRender, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { isRequestAPICallableInsideAfter } from './utils';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nexport function cookies() {\n    const callingExpression = 'cookies';\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !isRequestAPICallableInsideAfter()) {\n            throw Object.defineProperty(new Error(// TODO(after): clarify that this only applies to pages?\n            `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E88\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // cookies object without tracking\n            const underlyingCookies = createEmptyCookies();\n            return makeUntrackedExoticCookies(underlyingCookies);\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E549\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E398\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Error.captureStackTrace(error, cookies);\n                    workStore.invalidDynamicUsageError ??= error;\n                    throw error;\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E157\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                    return makeHangingCookies(workStore, workUnitStore);\n                case 'prerender-client':\n                    const exportName = '`cookies`';\n                    throw Object.defineProperty(new InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    // We need track dynamic access here eagerly to keep continuity with\n                    // how cookies has worked in PPR without cacheComponents.\n                    return postponeWithTracking(workStore.route, callingExpression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    // We track dynamic access here so we don't need to wrap the cookies\n                    // in individual property access tracking.\n                    return throwToInterruptStaticGeneration(callingExpression, workStore, workUnitStore);\n                case 'prerender-runtime':\n                    return delayUntilRuntimeStage(workUnitStore, makeUntrackedCookies(workUnitStore.cookies));\n                case 'private-cache':\n                    if (process.env.__NEXT_CACHE_COMPONENTS) {\n                        return makeUntrackedCookies(workUnitStore.cookies);\n                    }\n                    return makeUntrackedExoticCookies(workUnitStore.cookies);\n                case 'request':\n                    trackDynamicDataInDynamicRender(workUnitStore);\n                    let underlyingCookies;\n                    if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n                        // We can't conditionally return different types here based on the context.\n                        // To avoid confusion, we always return the readonly type here.\n                        underlyingCookies = workUnitStore.userspaceMutableCookies;\n                    } else {\n                        underlyingCookies = workUnitStore.cookies;\n                    }\n                    if (process.env.NODE_ENV === 'development') {\n                        // Semantically we only need the dev tracking when running in `next dev`\n                        // but since you would never use next dev with production NODE_ENV we use this\n                        // as a proxy so we can statically exclude this code from production builds.\n                        if (process.env.__NEXT_CACHE_COMPONENTS) {\n                            return makeUntrackedCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);\n                        }\n                        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);\n                    } else {\n                        if (process.env.__NEXT_CACHE_COMPONENTS) {\n                            return makeUntrackedCookies(underlyingCookies);\n                        }\n                        return makeUntrackedExoticCookies(underlyingCookies);\n                    }\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n    // If we end up here, there was no work store or work unit store present.\n    throwForMissingRequestStore(callingExpression);\n}\nfunction createEmptyCookies() {\n    return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})));\n}\nconst CachedCookies = new WeakMap();\nfunction makeHangingCookies(workStore, prerenderStore) {\n    const cachedPromise = CachedCookies.get(prerenderStore);\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    const promise = makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`cookies()`');\n    CachedCookies.set(prerenderStore, promise);\n    return promise;\n}\nfunction makeUntrackedCookies(underlyingCookies) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = Promise.resolve(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    return promise;\n}\nfunction makeUntrackedExoticCookies(underlyingCookies) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = Promise.resolve(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.bind(underlyingCookies)\n        },\n        size: {\n            get () {\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: underlyingCookies.get.bind(underlyingCookies)\n        },\n        getAll: {\n            value: underlyingCookies.getAll.bind(underlyingCookies)\n        },\n        has: {\n            value: underlyingCookies.has.bind(underlyingCookies)\n        },\n        set: {\n            value: underlyingCookies.set.bind(underlyingCookies)\n        },\n        delete: {\n            value: underlyingCookies.delete.bind(underlyingCookies)\n        },\n        clear: {\n            value: // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)\n        },\n        toString: {\n            value: underlyingCookies.toString.bind(underlyingCookies)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = makeDevtoolsIOAwarePromise(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...cookies()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n                // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesIterator.call(underlyingCookies);\n            },\n            writable: false\n        },\n        size: {\n            get () {\n                const expression = '`cookies().size`';\n                syncIODev(route, expression);\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().get()`';\n                } else {\n                    expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.get.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        getAll: {\n            value: function getAll() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().getAll()`';\n                } else {\n                    expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.getAll.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        has: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().has()`';\n                } else {\n                    expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.has.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        set: {\n            value: function set() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().set()`';\n                } else {\n                    const arg = arguments[0];\n                    if (arg) {\n                        expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``;\n                    } else {\n                        expression = '`cookies().set(...)`';\n                    }\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.set.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        delete: {\n            value: function() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().delete()`';\n                } else if (arguments.length === 1) {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``;\n                } else {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.delete.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        clear: {\n            value: function clear() {\n                const expression = '`cookies().clear()`';\n                syncIODev(route, expression);\n                // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n                // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesClear.call(underlyingCookies, promise);\n            },\n            writable: false\n        },\n        toString: {\n            value: function toString() {\n                const expression = '`cookies().toString()` or implicit casting';\n                syncIODev(route, expression);\n                return underlyingCookies.toString.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        }\n    });\n    return promise;\n}\n// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the\n// sync access without actually defining the cookies properties on the promise.\nfunction makeUntrackedCookiesWithDevWarnings(underlyingCookies, route) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = makeDevtoolsIOAwarePromise(underlyingCookies);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case Symbol.iterator:\n                    {\n                        warnForSyncAccess(route, '`...cookies()` or similar iteration');\n                        break;\n                    }\n                case 'size':\n                case 'get':\n                case 'getAll':\n                case 'has':\n                case 'set':\n                case 'delete':\n                case 'clear':\n                case 'toString':\n                    {\n                        warnForSyncAccess(route, `\\`cookies().${prop}\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the cookies object.\n                    }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    CachedCookies.set(underlyingCookies, proxiedPromise);\n    return proxiedPromise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? `'${arg.name}'` : typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createCookiesAccessError);\nfunction createCookiesAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`cookies()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E223\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction polyfilledResponseCookiesIterator() {\n    return this.getAll().map((c)=>[\n            c.name,\n            c\n        ]).values();\n}\nfunction polyfilledResponseCookiesClear(returnable) {\n    for (const cookie of this.getAll()){\n        this.delete(cookie.name);\n    }\n    return returnable;\n}\n\n//# sourceMappingURL=cookies.js.map","import { HeadersAdapter } from '../web/spec-extension/adapters/headers';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { throwForMissingRequestStore, workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { postponeWithTracking, throwToInterruptStaticGeneration, trackDynamicDataInDynamicRender, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { isRequestAPICallableInsideAfter } from './utils';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */ export function headers() {\n    const callingExpression = 'headers';\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !isRequestAPICallableInsideAfter()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E367\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // headers object without tracking\n            const underlyingHeaders = HeadersAdapter.seal(new Headers({}));\n            return makeUntrackedExoticHeaders(underlyingHeaders);\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E304\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, headers);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'private-cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"use cache: private\". Accessing \"headers\" inside a private cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E742\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, headers);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E127\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E525\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'prerender':\n                case 'prerender-runtime':\n                    return makeHangingHeaders(workStore, workUnitStore);\n                case 'prerender-client':\n                    const exportName = '`headers`';\n                    throw Object.defineProperty(new InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    // PPR Prerender (no cacheComponents)\n                    // We are prerendering with PPR. We need track dynamic access here eagerly\n                    // to keep continuity with how headers has worked in PPR without cacheComponents.\n                    // TODO consider switching the semantic to throw on property access instead\n                    return postponeWithTracking(workStore.route, callingExpression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    // Legacy Prerender\n                    // We are in a legacy static generation mode while prerendering\n                    // We track dynamic access here so we don't need to wrap the headers in\n                    // individual property access tracking.\n                    return throwToInterruptStaticGeneration(callingExpression, workStore, workUnitStore);\n                case 'request':\n                    trackDynamicDataInDynamicRender(workUnitStore);\n                    if (process.env.NODE_ENV === 'development') {\n                        // Semantically we only need the dev tracking when running in `next dev`\n                        // but since you would never use next dev with production NODE_ENV we use this\n                        // as a proxy so we can statically exclude this code from production builds.\n                        if (process.env.__NEXT_CACHE_COMPONENTS) {\n                            return makeUntrackedHeadersWithDevWarnings(workUnitStore.headers, workStore == null ? void 0 : workStore.route);\n                        }\n                        return makeUntrackedExoticHeadersWithDevWarnings(workUnitStore.headers, workStore == null ? void 0 : workStore.route);\n                    } else {\n                        if (process.env.__NEXT_CACHE_COMPONENTS) {\n                            return makeUntrackedHeaders(workUnitStore.headers);\n                        }\n                        return makeUntrackedExoticHeaders(workUnitStore.headers);\n                    }\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n    // If we end up here, there was no work store or work unit store present.\n    throwForMissingRequestStore(callingExpression);\n}\nconst CachedHeaders = new WeakMap();\nfunction makeHangingHeaders(workStore, prerenderStore) {\n    const cachedHeaders = CachedHeaders.get(prerenderStore);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`headers()`');\n    CachedHeaders.set(prerenderStore, promise);\n    return promise;\n}\nfunction makeUntrackedHeaders(underlyingHeaders) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = Promise.resolve(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    return promise;\n}\nfunction makeUntrackedExoticHeaders(underlyingHeaders) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = Promise.resolve(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: underlyingHeaders.append.bind(underlyingHeaders)\n        },\n        delete: {\n            value: underlyingHeaders.delete.bind(underlyingHeaders)\n        },\n        get: {\n            value: underlyingHeaders.get.bind(underlyingHeaders)\n        },\n        has: {\n            value: underlyingHeaders.has.bind(underlyingHeaders)\n        },\n        set: {\n            value: underlyingHeaders.set.bind(underlyingHeaders)\n        },\n        getSetCookie: {\n            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)\n        },\n        forEach: {\n            value: underlyingHeaders.forEach.bind(underlyingHeaders)\n        },\n        keys: {\n            value: underlyingHeaders.keys.bind(underlyingHeaders)\n        },\n        values: {\n            value: underlyingHeaders.values.bind(underlyingHeaders)\n        },\n        entries: {\n            value: underlyingHeaders.entries.bind(underlyingHeaders)\n        },\n        [Symbol.iterator]: {\n            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = makeDevtoolsIOAwarePromise(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: function append() {\n                const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.append.apply(underlyingHeaders, arguments);\n            }\n        },\n        delete: {\n            value: function _delete() {\n                const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);\n            }\n        },\n        get: {\n            value: function get() {\n                const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.get.apply(underlyingHeaders, arguments);\n            }\n        },\n        has: {\n            value: function has() {\n                const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.has.apply(underlyingHeaders, arguments);\n            }\n        },\n        set: {\n            value: function set() {\n                const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.set.apply(underlyingHeaders, arguments);\n            }\n        },\n        getSetCookie: {\n            value: function getSetCookie() {\n                const expression = '`headers().getSetCookie()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);\n            }\n        },\n        forEach: {\n            value: function forEach() {\n                const expression = '`headers().forEach(...)`';\n                syncIODev(route, expression);\n                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);\n            }\n        },\n        keys: {\n            value: function keys() {\n                const expression = '`headers().keys()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);\n            }\n        },\n        values: {\n            value: function values() {\n                const expression = '`headers().values()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.values.apply(underlyingHeaders, arguments);\n            }\n        },\n        entries: {\n            value: function entries() {\n                const expression = '`headers().entries()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);\n            }\n        },\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...headers()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);\n            }\n        }\n    });\n    return promise;\n}\n// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the\n// sync access without actually defining the headers properties on the promise.\nfunction makeUntrackedHeadersWithDevWarnings(underlyingHeaders, route) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = makeDevtoolsIOAwarePromise(underlyingHeaders);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case Symbol.iterator:\n                    {\n                        warnForSyncAccess(route, '`...headers()` or similar iteration');\n                        break;\n                    }\n                case 'append':\n                case 'delete':\n                case 'get':\n                case 'has':\n                case 'set':\n                case 'getSetCookie':\n                case 'forEach':\n                case 'keys':\n                case 'values':\n                case 'entries':\n                    {\n                        warnForSyncAccess(route, `\\`headers().${prop}\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the headers object.\n                    }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    CachedHeaders.set(underlyingHeaders, proxiedPromise);\n    return proxiedPromise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createHeadersAccessError);\nfunction createHeadersAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`headers()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E277\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=headers.js.map","import { ensureAuthUsersTable, runD1Query } from \"@/lib/cloudflareD1\";\n\nexport async function isAuthUserSessionValid(params: {\n  email: string;\n  sessionIssuedAt?: string;\n}): Promise<boolean> {\n  await ensureAuthUsersTable();\n  const rows = await runD1Query<{\n    is_active: number;\n    force_logout_after: string | null;\n  }>(\"SELECT is_active, force_logout_after FROM auth_users WHERE email = ? LIMIT 1\", [\n    params.email.trim().toLowerCase(),\n  ]);\n\n  const row = rows[0];\n  if (!row) return true;\n  if (!row.is_active) return false;\n\n  if (!row.force_logout_after) return true;\n  if (!params.sessionIssuedAt) return false;\n\n  const issuedAt = Date.parse(params.sessionIssuedAt);\n  const forceLogoutAfter = Date.parse(row.force_logout_after);\n\n  if (Number.isNaN(issuedAt) || Number.isNaN(forceLogoutAfter)) return false;\n  return issuedAt > forceLogoutAfter;\n}\n","import { AUTH_COOKIE_NAME, type AuthUser, decodeAuthUser } from \"@/lib/authCookie\";\nimport { findAuthUserByEmail } from \"@/lib/authDb\";\nimport { isAuthUserSessionValid } from \"@/lib/authSession\";\nimport { cookies } from \"next/headers\";\n\nexport async function getRequestAuthUser(): Promise<AuthUser | null> {\n  const cookieStore = await cookies();\n  const cookieValue = cookieStore.get(AUTH_COOKIE_NAME)?.value;\n  const user = decodeAuthUser(cookieValue);\n  if (!user) return null;\n\n  try {\n    const [dbUser, validSession] = await Promise.all([\n      findAuthUserByEmail(user.email),\n      isAuthUserSessionValid({ email: user.email, sessionIssuedAt: user.sessionIssuedAt }),\n    ]);\n\n    if (!validSession) return null;\n\n    if (dbUser) {\n      return {\n        ...user,\n        role: dbUser.role,\n      };\n    }\n  } catch {\n    // Graceful fallback: keep cookie user if DB unavailable.\n  }\n\n  return user;\n}\n","import { getDraftModeProviderForCacheScope, throwForMissingRequestStore } from '../app-render/work-unit-async-storage.external';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { abortAndThrowOnSynchronousRequestDataAccess, delayUntilRuntimeStage, postponeWithTracking, trackDynamicDataInDynamicRender, trackSynchronousRequestDataAccessInDev } from '../app-render/dynamic-rendering';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nexport function draftMode() {\n    const callingExpression = 'draftMode';\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (!workStore || !workUnitStore) {\n        throwForMissingRequestStore(callingExpression);\n    }\n    switch(workUnitStore.type){\n        case 'prerender-runtime':\n            // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n            return delayUntilRuntimeStage(workUnitStore, createOrGetCachedDraftMode(workUnitStore.draftMode, workStore));\n        case 'request':\n            return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore);\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n            // the outmost work unit store is a request store (or a runtime prerender),\n            // and if draft mode is enabled.\n            const draftModeProvider = getDraftModeProviderForCacheScope(workStore, workUnitStore);\n            if (draftModeProvider) {\n                return createOrGetCachedDraftMode(draftModeProvider, workStore);\n            }\n        // Otherwise, we fall through to providing an empty draft mode.\n        // eslint-disable-next-line no-fallthrough\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n            // Return empty draft mode\n            return createOrGetCachedDraftMode(null, workStore);\n        default:\n            return workUnitStore;\n    }\n}\nfunction createOrGetCachedDraftMode(draftModeProvider, workStore) {\n    const cacheKey = draftModeProvider ?? NullDraftMode;\n    const cachedDraftMode = CachedDraftModes.get(cacheKey);\n    if (cachedDraftMode) {\n        return cachedDraftMode;\n    }\n    let promise;\n    if (process.env.NODE_ENV === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n        const route = workStore == null ? void 0 : workStore.route;\n        if (process.env.__NEXT_CACHE_COMPONENTS) {\n            return createDraftModeWithDevWarnings(draftModeProvider, route);\n        }\n        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);\n    } else {\n        if (process.env.__NEXT_CACHE_COMPONENTS) {\n            return Promise.resolve(new DraftMode(draftModeProvider));\n        }\n        promise = createExoticDraftMode(draftModeProvider);\n    }\n    CachedDraftModes.set(cacheKey, promise);\n    return promise;\n}\nconst NullDraftMode = {};\nconst CachedDraftModes = new WeakMap();\nfunction createExoticDraftMode(underlyingProvider) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            return instance.isEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    promise.enable = instance.enable.bind(instance);\n    promise.disable = instance.disable.bind(instance);\n    return promise;\n}\nfunction createExoticDraftModeWithDevWarnings(underlyingProvider, route) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            const expression = '`draftMode().isEnabled`';\n            syncIODev(route, expression);\n            return instance.isEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(promise, 'enable', {\n        value: function get() {\n            const expression = '`draftMode().enable()`';\n            syncIODev(route, expression);\n            return instance.enable.apply(instance, arguments);\n        }\n    });\n    Object.defineProperty(promise, 'disable', {\n        value: function get() {\n            const expression = '`draftMode().disable()`';\n            syncIODev(route, expression);\n            return instance.disable.apply(instance, arguments);\n        }\n    });\n    return promise;\n}\n// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync\n// access without actually defining the draftMode properties on the promise.\nfunction createDraftModeWithDevWarnings(underlyingProvider, route) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case 'isEnabled':\n                    warnForSyncAccess(route, `\\`draftMode().${prop}\\``);\n                    break;\n                case 'enable':\n                case 'disable':\n                    {\n                        warnForSyncAccess(route, `\\`draftMode().${prop}()\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the draftMode object.\n                    }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    return proxiedPromise;\n}\nclass DraftMode {\n    constructor(provider){\n        this._provider = provider;\n    }\n    get isEnabled() {\n        if (this._provider !== null) {\n            return this._provider.isEnabled;\n        }\n        return false;\n    }\n    enable() {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        trackDynamicDraftMode('draftMode().enable()', this.enable);\n        if (this._provider !== null) {\n            this._provider.enable();\n        }\n    }\n    disable() {\n        trackDynamicDraftMode('draftMode().disable()', this.disable);\n        if (this._provider !== null) {\n            this._provider.disable();\n        }\n    }\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createDraftModeAccessError);\nfunction createDraftModeAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`draftMode()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E377\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction trackDynamicDraftMode(expression, constructorOpt) {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore) {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        if ((workUnitStore == null ? void 0 : workUnitStore.phase) === 'after') {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E348\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E553\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                case 'private-cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E246\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, constructorOpt);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E259\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                case 'prerender-runtime':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E126\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        return abortAndThrowOnSynchronousRequestDataAccess(workStore.route, expression, error, workUnitStore);\n                    }\n                case 'prerender-client':\n                    const exportName = '`draftMode`';\n                    throw Object.defineProperty(new InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    workUnitStore.revalidate = 0;\n                    const err = Object.defineProperty(new DynamicServerError(`Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E558\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    workStore.dynamicUsageDescription = expression;\n                    workStore.dynamicUsageStack = err.stack;\n                    throw err;\n                case 'request':\n                    trackDynamicDataInDynamicRender(workUnitStore);\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=draft-mode.js.map"],"names":[],"mappings":"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","ignoreList":[0,1,4]}