{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/roles.ts"],"sourcesContent":["import type { AuthUser } from \"@/lib/authCookie\";\n\nexport type AppRole = \"USER\" | \"ADMIN\" | \"TEMPLATE_ADMIN\" | \"SUPER_ADMIN\";\n\nconst DEFAULT_SUPER_ADMIN_EMAIL = \"badryansah99@gmail.com\";\n\nfunction normalizeEmail(email: string): string {\n  return email.trim().toLowerCase();\n}\n\nfunction getConfiguredEmails(envName: string, fallback = \"\"): Set<string> {\n  const raw = process.env[envName] ?? fallback;\n  const emails = raw\n    .split(\",\")\n    .map((email) => normalizeEmail(email))\n    .filter((email) => email.length > 0);\n\n  return new Set(emails);\n}\n\nfunction isInSet(email: string, emails: Set<string>): boolean {\n  return emails.has(normalizeEmail(email));\n}\n\nexport function getUserRoleByEmail(email: string): AppRole {\n  const normalized = normalizeEmail(email);\n  const superAdmins = getConfiguredEmails(\"SUPER_ADMIN_EMAILS\", DEFAULT_SUPER_ADMIN_EMAIL);\n  if (isInSet(normalized, superAdmins)) return \"SUPER_ADMIN\";\n\n  const admins = getConfiguredEmails(\"ADMIN_EMAILS\");\n  if (isInSet(normalized, admins)) return \"ADMIN\";\n\n  const templateAdmins = getConfiguredEmails(\"TEMPLATE_ADMIN_EMAILS\");\n  if (isInSet(normalized, templateAdmins)) return \"TEMPLATE_ADMIN\";\n\n  return \"USER\";\n}\n\nexport function getUserRole(user: AuthUser | null | undefined): AppRole {\n  if (!user?.email) return \"USER\";\n  const emailBasedRole = getUserRoleByEmail(user.email);\n  if (emailBasedRole === \"SUPER_ADMIN\") return \"SUPER_ADMIN\";\n\n  if (\n    user.role === \"USER\" ||\n    user.role === \"ADMIN\" ||\n    user.role === \"TEMPLATE_ADMIN\" ||\n    user.role === \"SUPER_ADMIN\"\n  ) {\n    return user.role;\n  }\n\n  return emailBasedRole;\n}\n\nexport function canAccessAdminPage(role: AppRole): boolean {\n  return role === \"ADMIN\" || role === \"SUPER_ADMIN\";\n}\n\nexport function canAccessTemplateManagerPage(role: AppRole): boolean {\n  return role === \"TEMPLATE_ADMIN\" || role === \"SUPER_ADMIN\";\n}\n\nexport function canAccessSuperAdminPage(role: AppRole): boolean {\n  return role === \"SUPER_ADMIN\";\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAIA,MAAM,4BAA4B;AAElC,SAAS,eAAe,KAAa;IACnC,OAAO,MAAM,IAAI,GAAG,WAAW;AACjC;AAEA,SAAS,oBAAoB,OAAe,EAAE,WAAW,EAAE;IACzD,MAAM,MAAM,QAAQ,GAAG,CAAC,QAAQ,IAAI;IACpC,MAAM,SAAS,IACZ,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,QAAU,eAAe,QAC9B,MAAM,CAAC,CAAC,QAAU,MAAM,MAAM,GAAG;IAEpC,OAAO,IAAI,IAAI;AACjB;AAEA,SAAS,QAAQ,KAAa,EAAE,MAAmB;IACjD,OAAO,OAAO,GAAG,CAAC,eAAe;AACnC;AAEO,SAAS,mBAAmB,KAAa;IAC9C,MAAM,aAAa,eAAe;IAClC,MAAM,cAAc,oBAAoB,sBAAsB;IAC9D,IAAI,QAAQ,YAAY,cAAc,OAAO;IAE7C,MAAM,SAAS,oBAAoB;IACnC,IAAI,QAAQ,YAAY,SAAS,OAAO;IAExC,MAAM,iBAAiB,oBAAoB;IAC3C,IAAI,QAAQ,YAAY,iBAAiB,OAAO;IAEhD,OAAO;AACT;AAEO,SAAS,YAAY,IAAiC;IAC3D,IAAI,CAAC,MAAM,OAAO,OAAO;IACzB,MAAM,iBAAiB,mBAAmB,KAAK,KAAK;IACpD,IAAI,mBAAmB,eAAe,OAAO;IAE7C,IACE,KAAK,IAAI,KAAK,UACd,KAAK,IAAI,KAAK,WACd,KAAK,IAAI,KAAK,oBACd,KAAK,IAAI,KAAK,eACd;QACA,OAAO,KAAK,IAAI;IAClB;IAEA,OAAO;AACT;AAEO,SAAS,mBAAmB,IAAa;IAC9C,OAAO,SAAS,WAAW,SAAS;AACtC;AAEO,SAAS,6BAA6B,IAAa;IACxD,OAAO,SAAS,oBAAoB,SAAS;AAC/C;AAEO,SAAS,wBAAwB,IAAa;IACnD,OAAO,SAAS;AAClB"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/adminAccess.ts"],"sourcesContent":["import type { AuthUser } from \"@/lib/authCookie\";\nimport {\n  type AppRole,\n  canAccessAdminPage,\n  canAccessSuperAdminPage,\n  canAccessTemplateManagerPage,\n  getUserRole,\n  getUserRoleByEmail,\n} from \"@/lib/roles\";\n\nexport type { AppRole };\n\nexport function getRoleFromUser(user: AuthUser | null | undefined): AppRole {\n  return getUserRole(user);\n}\n\nexport function getRoleFromEmail(email: string): AppRole {\n  return getUserRoleByEmail(email);\n}\n\nexport function isAdminEmail(email: string): boolean {\n  return canAccessAdminPage(getUserRoleByEmail(email));\n}\n\nexport function isAdminUser(user: AuthUser | null | undefined): boolean {\n  return canAccessAdminPage(getUserRole(user));\n}\n\nexport function isTemplateAdminUser(user: AuthUser | null | undefined): boolean {\n  return canAccessTemplateManagerPage(getUserRole(user));\n}\n\nexport function isSuperAdminUser(user: AuthUser | null | undefined): boolean {\n  return canAccessSuperAdminPage(getUserRole(user));\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AACA;;AAWO,SAAS,gBAAgB,IAAiC;IAC/D,OAAO,IAAA,mIAAW,EAAC;AACrB;AAEO,SAAS,iBAAiB,KAAa;IAC5C,OAAO,IAAA,0IAAkB,EAAC;AAC5B;AAEO,SAAS,aAAa,KAAa;IACxC,OAAO,IAAA,0IAAkB,EAAC,IAAA,0IAAkB,EAAC;AAC/C;AAEO,SAAS,YAAY,IAAiC;IAC3D,OAAO,IAAA,0IAAkB,EAAC,IAAA,mIAAW,EAAC;AACxC;AAEO,SAAS,oBAAoB,IAAiC;IACnE,OAAO,IAAA,oJAA4B,EAAC,IAAA,mIAAW,EAAC;AAClD;AAEO,SAAS,iBAAiB,IAAiC;IAChE,OAAO,IAAA,+IAAuB,EAAC,IAAA,mIAAW,EAAC;AAC7C"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/cloudflareD1.ts"],"sourcesContent":["const CLOUDFLARE_API_BASE = \"https://api.cloudflare.com/client/v4\";\nlet ensureAuthUsersTablePromise: Promise<void> | null = null;\n\ntype D1Result<T = Record<string, unknown>> = {\n  success: boolean;\n  result: Array<{\n    success: boolean;\n    results?: T[];\n    meta?: Record<string, unknown>;\n  }>;\n  errors?: Array<{ message?: string }>;\n};\n\nfunction getD1Config() {\n  const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;\n  const databaseId = process.env.CLOUDFLARE_D1_DATABASE_ID;\n  const apiToken = process.env.CLOUDFLARE_API_TOKEN;\n\n  if (!accountId || !databaseId || !apiToken) {\n    throw new Error(\n      \"Missing Cloudflare D1 env vars: CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_D1_DATABASE_ID, CLOUDFLARE_API_TOKEN\"\n    );\n  }\n\n  return { accountId, databaseId, apiToken };\n}\n\nexport async function runD1Query<T = Record<string, unknown>>(\n  sql: string,\n  params: unknown[] = []\n): Promise<T[]> {\n  const { accountId, databaseId, apiToken } = getD1Config();\n  const endpoint = `${CLOUDFLARE_API_BASE}/accounts/${accountId}/d1/database/${databaseId}/query`;\n\n  const response = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiToken}`,\n    },\n    body: JSON.stringify({ sql, params }),\n    cache: \"no-store\",\n  });\n\n  if (!response.ok) {\n    const text = await response.text();\n    throw new Error(`D1 query failed (${response.status}): ${text}`);\n  }\n\n  const payload = (await response.json()) as D1Result<T>;\n  if (!payload.success) {\n    const message = payload.errors?.[0]?.message ?? \"Unknown D1 error\";\n    throw new Error(message);\n  }\n\n  return payload.result?.[0]?.results ?? [];\n}\n\nasync function ensureAuthUsersTableInner() {\n  await runD1Query(`\n    CREATE TABLE IF NOT EXISTS auth_users (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL,\n      email TEXT NOT NULL UNIQUE,\n      password_hash TEXT NOT NULL,\n      role TEXT NOT NULL DEFAULT 'USER',\n      is_active INTEGER NOT NULL DEFAULT 1,\n      must_change_password INTEGER NOT NULL DEFAULT 0,\n      force_logout_after TEXT,\n      last_login_at TEXT,\n      email_verified_at TEXT,\n      notes TEXT,\n      created_at TEXT NOT NULL,\n      updated_at TEXT NOT NULL\n    );\n  `);\n\n  const columns = await runD1Query<{ name: string }>(\"PRAGMA table_info(auth_users)\");\n  const hasEmailVerifiedAt = columns.some((column) => column.name === \"email_verified_at\");\n  if (!hasEmailVerifiedAt) {\n    await runD1Query(\"ALTER TABLE auth_users ADD COLUMN email_verified_at TEXT\");\n  }\n\n  const hasRole = columns.some((column) => column.name === \"role\");\n  if (!hasRole) {\n    await runD1Query(\"ALTER TABLE auth_users ADD COLUMN role TEXT NOT NULL DEFAULT 'USER'\");\n  }\n\n  const hasIsActive = columns.some((column) => column.name === \"is_active\");\n  if (!hasIsActive) {\n    await runD1Query(\"ALTER TABLE auth_users ADD COLUMN is_active INTEGER NOT NULL DEFAULT 1\");\n  }\n\n  const hasMustChangePassword = columns.some((column) => column.name === \"must_change_password\");\n  if (!hasMustChangePassword) {\n    await runD1Query(\n      \"ALTER TABLE auth_users ADD COLUMN must_change_password INTEGER NOT NULL DEFAULT 0\"\n    );\n  }\n\n  const hasForceLogoutAfter = columns.some((column) => column.name === \"force_logout_after\");\n  if (!hasForceLogoutAfter) {\n    await runD1Query(\"ALTER TABLE auth_users ADD COLUMN force_logout_after TEXT\");\n  }\n\n  const hasLastLoginAt = columns.some((column) => column.name === \"last_login_at\");\n  if (!hasLastLoginAt) {\n    await runD1Query(\"ALTER TABLE auth_users ADD COLUMN last_login_at TEXT\");\n  }\n}\n\nexport async function ensureAuthUsersTable(): Promise<void> {\n  if (!ensureAuthUsersTablePromise) {\n    ensureAuthUsersTablePromise = ensureAuthUsersTableInner().catch((error) => {\n      ensureAuthUsersTablePromise = null;\n      throw error;\n    });\n  }\n\n  await ensureAuthUsersTablePromise;\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,sBAAsB;AAC5B,IAAI,8BAAoD;AAYxD,SAAS;IACP,MAAM,YAAY,QAAQ,GAAG,CAAC,qBAAqB;IACnD,MAAM,aAAa,QAAQ,GAAG,CAAC,yBAAyB;IACxD,MAAM,WAAW,QAAQ,GAAG,CAAC,oBAAoB;IAEjD,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU;QAC1C,MAAM,IAAI,MACR;IAEJ;IAEA,OAAO;QAAE;QAAW;QAAY;IAAS;AAC3C;AAEO,eAAe,WACpB,GAAW,EACX,SAAoB,EAAE;IAEtB,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,QAAQ,EAAE,GAAG;IAC5C,MAAM,WAAW,GAAG,oBAAoB,UAAU,EAAE,UAAU,aAAa,EAAE,WAAW,MAAM,CAAC;IAE/F,MAAM,WAAW,MAAM,MAAM,UAAU;QACrC,QAAQ;QACR,SAAS;YACP,gBAAgB;YAChB,eAAe,CAAC,OAAO,EAAE,UAAU;QACrC;QACA,MAAM,KAAK,SAAS,CAAC;YAAE;YAAK;QAAO;QACnC,OAAO;IACT;IAEA,IAAI,CAAC,SAAS,EAAE,EAAE;QAChB,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,MAAM;IACjE;IAEA,MAAM,UAAW,MAAM,SAAS,IAAI;IACpC,IAAI,CAAC,QAAQ,OAAO,EAAE;QACpB,MAAM,UAAU,QAAQ,MAAM,EAAE,CAAC,EAAE,EAAE,WAAW;QAChD,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,QAAQ,MAAM,EAAE,CAAC,EAAE,EAAE,WAAW,EAAE;AAC3C;AAEA,eAAe;IACb,MAAM,WAAW,CAAC;;;;;;;;;;;;;;;;EAgBlB,CAAC;IAED,MAAM,UAAU,MAAM,WAA6B;IACnD,MAAM,qBAAqB,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IACpE,IAAI,CAAC,oBAAoB;QACvB,MAAM,WAAW;IACnB;IAEA,MAAM,UAAU,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IACzD,IAAI,CAAC,SAAS;QACZ,MAAM,WAAW;IACnB;IAEA,MAAM,cAAc,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IAC7D,IAAI,CAAC,aAAa;QAChB,MAAM,WAAW;IACnB;IAEA,MAAM,wBAAwB,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IACvE,IAAI,CAAC,uBAAuB;QAC1B,MAAM,WACJ;IAEJ;IAEA,MAAM,sBAAsB,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IACrE,IAAI,CAAC,qBAAqB;QACxB,MAAM,WAAW;IACnB;IAEA,MAAM,iBAAiB,QAAQ,IAAI,CAAC,CAAC,SAAW,OAAO,IAAI,KAAK;IAChE,IAAI,CAAC,gBAAgB;QACnB,MAAM,WAAW;IACnB;AACF;AAEO,eAAe;IACpB,IAAI,CAAC,6BAA6B;QAChC,8BAA8B,4BAA4B,KAAK,CAAC,CAAC;YAC/D,8BAA8B;YAC9B,MAAM;QACR;IACF;IAEA,MAAM;AACR"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/authSession.ts"],"sourcesContent":["import { ensureAuthUsersTable, runD1Query } from \"@/lib/cloudflareD1\";\n\nexport async function isAuthUserSessionValid(params: {\n  email: string;\n  sessionIssuedAt?: string;\n}): Promise<boolean> {\n  await ensureAuthUsersTable();\n  const rows = await runD1Query<{\n    is_active: number;\n    force_logout_after: string | null;\n  }>(\"SELECT is_active, force_logout_after FROM auth_users WHERE email = ? LIMIT 1\", [\n    params.email.trim().toLowerCase(),\n  ]);\n\n  const row = rows[0];\n  if (!row) return true;\n  if (!row.is_active) return false;\n\n  if (!row.force_logout_after) return true;\n  if (!params.sessionIssuedAt) return false;\n\n  const issuedAt = Date.parse(params.sessionIssuedAt);\n  const forceLogoutAfter = Date.parse(row.force_logout_after);\n\n  if (Number.isNaN(issuedAt) || Number.isNaN(forceLogoutAfter)) return false;\n  return issuedAt > forceLogoutAfter;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,eAAe,uBAAuB,MAG5C;IACC,MAAM,IAAA,mJAAoB;IAC1B,MAAM,OAAO,MAAM,IAAA,yIAAU,EAG1B,gFAAgF;QACjF,OAAO,KAAK,CAAC,IAAI,GAAG,WAAW;KAChC;IAED,MAAM,MAAM,IAAI,CAAC,EAAE;IACnB,IAAI,CAAC,KAAK,OAAO;IACjB,IAAI,CAAC,IAAI,SAAS,EAAE,OAAO;IAE3B,IAAI,CAAC,IAAI,kBAAkB,EAAE,OAAO;IACpC,IAAI,CAAC,OAAO,eAAe,EAAE,OAAO;IAEpC,MAAM,WAAW,KAAK,KAAK,CAAC,OAAO,eAAe;IAClD,MAAM,mBAAmB,KAAK,KAAK,CAAC,IAAI,kBAAkB;IAE1D,IAAI,OAAO,KAAK,CAAC,aAAa,OAAO,KAAK,CAAC,mBAAmB,OAAO;IACrE,OAAO,WAAW;AACpB"}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/authCookie.ts"],"sourcesContent":["export const AUTH_COOKIE_NAME = \"tamplateku_auth_user\";\n\nexport type AuthRole = \"USER\" | \"ADMIN\" | \"TEMPLATE_ADMIN\" | \"SUPER_ADMIN\";\n\nexport type AuthUser = {\n  id: string;\n  email: string;\n  name: string;\n  picture?: string;\n  provider: \"google\" | \"github\" | \"local\";\n  role?: AuthRole;\n  sessionIssuedAt?: string;\n};\n\nexport function encodeAuthUser(user: AuthUser): string {\n  return JSON.stringify(user);\n}\n\nexport function decodeAuthUser(value: string | undefined): AuthUser | null {\n  if (!value) return null;\n\n  const parseCandidate = (candidate: string): AuthUser | null => {\n    try {\n      const parsed = JSON.parse(candidate) as Partial<AuthUser>;\n      if (\n        typeof parsed.id === \"string\" &&\n        typeof parsed.email === \"string\" &&\n        typeof parsed.name === \"string\" &&\n        (parsed.provider === \"google\" || parsed.provider === \"github\" || parsed.provider === \"local\")\n      ) {\n        return {\n          id: parsed.id,\n          email: parsed.email,\n          name: parsed.name,\n          picture: typeof parsed.picture === \"string\" ? parsed.picture : undefined,\n          provider: parsed.provider,\n          role:\n            parsed.role === \"USER\" ||\n            parsed.role === \"ADMIN\" ||\n            parsed.role === \"TEMPLATE_ADMIN\" ||\n            parsed.role === \"SUPER_ADMIN\"\n              ? parsed.role\n              : undefined,\n          sessionIssuedAt:\n            typeof parsed.sessionIssuedAt === \"string\" ? parsed.sessionIssuedAt : undefined,\n        };\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  };\n\n  const direct = parseCandidate(value);\n  if (direct) return direct;\n\n  try {\n    return parseCandidate(decodeURIComponent(value));\n  } catch {\n    return null;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,mBAAmB;AAczB,SAAS,eAAe,IAAc;IAC3C,OAAO,KAAK,SAAS,CAAC;AACxB;AAEO,SAAS,eAAe,KAAyB;IACtD,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,iBAAiB,CAAC;QACtB,IAAI;YACF,MAAM,SAAS,KAAK,KAAK,CAAC;YAC1B,IACE,OAAO,OAAO,EAAE,KAAK,YACrB,OAAO,OAAO,KAAK,KAAK,YACxB,OAAO,OAAO,IAAI,KAAK,YACvB,CAAC,OAAO,QAAQ,KAAK,YAAY,OAAO,QAAQ,KAAK,YAAY,OAAO,QAAQ,KAAK,OAAO,GAC5F;gBACA,OAAO;oBACL,IAAI,OAAO,EAAE;oBACb,OAAO,OAAO,KAAK;oBACnB,MAAM,OAAO,IAAI;oBACjB,SAAS,OAAO,OAAO,OAAO,KAAK,WAAW,OAAO,OAAO,GAAG;oBAC/D,UAAU,OAAO,QAAQ;oBACzB,MACE,OAAO,IAAI,KAAK,UAChB,OAAO,IAAI,KAAK,WAChB,OAAO,IAAI,KAAK,oBAChB,OAAO,IAAI,KAAK,gBACZ,OAAO,IAAI,GACX;oBACN,iBACE,OAAO,OAAO,eAAe,KAAK,WAAW,OAAO,eAAe,GAAG;gBAC1E;YACF;YACA,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,MAAM,SAAS,eAAe;IAC9B,IAAI,QAAQ,OAAO;IAEnB,IAAI;QACF,OAAO,eAAe,mBAAmB;IAC3C,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/superAdminDb.ts"],"sourcesContent":["import { runD1Query } from \"@/lib/cloudflareD1\";\nimport type { AppRole } from \"@/lib/roles\";\nlet ensureSuperAdminTablesPromise: Promise<void> | null = null;\nconst SYSTEM_CONFIG_CACHE_TTL_MS = 15_000;\nlet cachedSystemConfig: { value: SystemConfig; expiresAt: number } | null = null;\n\nexport type AccessModule = \"adminPage\" | \"templateManagerPage\" | \"superAdminPage\";\n\nexport type RoleAccessPolicy = Record<AppRole, Record<AccessModule, boolean>>;\n\nexport type SystemConfig = {\n  appName: string;\n  appLogoUrl: string;\n  maintenanceMode: boolean;\n  loginAccess: {\n    formLoginEnabled: boolean;\n    googleLoginEnabled: boolean;\n  };\n  features: {\n    browseTemplateEnabled: boolean;\n    blogEnabled: boolean;\n  };\n  integrations: {\n    resendEnabled: boolean;\n    googleOauthEnabled: boolean;\n    publicApiEnabled: boolean;\n    publicApiKeyHint: string;\n  };\n  roleAccess: RoleAccessPolicy;\n};\n\nconst DEFAULT_ROLE_ACCESS: RoleAccessPolicy = {\n  USER: {\n    adminPage: false,\n    templateManagerPage: false,\n    superAdminPage: false,\n  },\n  ADMIN: {\n    adminPage: true,\n    templateManagerPage: false,\n    superAdminPage: false,\n  },\n  TEMPLATE_ADMIN: {\n    adminPage: false,\n    templateManagerPage: true,\n    superAdminPage: false,\n  },\n  SUPER_ADMIN: {\n    adminPage: true,\n    templateManagerPage: true,\n    superAdminPage: true,\n  },\n};\n\nexport const DEFAULT_SYSTEM_CONFIG: SystemConfig = {\n  appName: \"Tamplateku\",\n  appLogoUrl: \"/logo.png\",\n  maintenanceMode: false,\n  loginAccess: {\n    formLoginEnabled: true,\n    googleLoginEnabled: true,\n  },\n  features: {\n    browseTemplateEnabled: true,\n    blogEnabled: true,\n  },\n  integrations: {\n    resendEnabled: true,\n    googleOauthEnabled: true,\n    publicApiEnabled: false,\n    publicApiKeyHint: \"\",\n  },\n  roleAccess: DEFAULT_ROLE_ACCESS,\n};\n\ntype AuditLogRow = {\n  id: string;\n  actor_email: string;\n  action: string;\n  target_type: string;\n  target_id: string | null;\n  detail_json: string | null;\n  severity: string;\n  created_at: string;\n};\n\ntype LoginLogRow = {\n  id: string;\n  user_id: string | null;\n  email: string;\n  success: number;\n  reason: string | null;\n  request_ip: string;\n  user_agent: string;\n  created_at: string;\n};\n\ntype BackupRow = {\n  id: string;\n  snapshot_type: string;\n  payload_json: string;\n  created_by: string;\n  created_at: string;\n};\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction toBoolean(value: unknown, fallback: boolean): boolean {\n  return typeof value === \"boolean\" ? value : fallback;\n}\n\nfunction toStringValue(value: unknown, fallback: string): string {\n  if (typeof value !== \"string\") return fallback;\n  const trimmed = value.trim();\n  return trimmed.length > 0 ? trimmed : fallback;\n}\n\nfunction mergeRoleAccess(raw: unknown): RoleAccessPolicy {\n  if (!isRecord(raw)) return DEFAULT_ROLE_ACCESS;\n\n  const roles: AppRole[] = [\"USER\", \"ADMIN\", \"TEMPLATE_ADMIN\", \"SUPER_ADMIN\"];\n  const result: RoleAccessPolicy = {\n    USER: { ...DEFAULT_ROLE_ACCESS.USER },\n    ADMIN: { ...DEFAULT_ROLE_ACCESS.ADMIN },\n    TEMPLATE_ADMIN: { ...DEFAULT_ROLE_ACCESS.TEMPLATE_ADMIN },\n    SUPER_ADMIN: { ...DEFAULT_ROLE_ACCESS.SUPER_ADMIN },\n  };\n\n  for (const role of roles) {\n    const roleRaw = raw[role];\n    if (!isRecord(roleRaw)) continue;\n\n    result[role] = {\n      adminPage: toBoolean(roleRaw.adminPage, result[role].adminPage),\n      templateManagerPage: toBoolean(roleRaw.templateManagerPage, result[role].templateManagerPage),\n      superAdminPage: toBoolean(roleRaw.superAdminPage, result[role].superAdminPage),\n    };\n  }\n\n  result.SUPER_ADMIN = {\n    adminPage: true,\n    templateManagerPage: true,\n    superAdminPage: true,\n  };\n\n  return result;\n}\n\nfunction mergeSystemConfig(raw: unknown): SystemConfig {\n  if (!isRecord(raw)) return DEFAULT_SYSTEM_CONFIG;\n\n  const loginAccess = isRecord(raw.loginAccess) ? raw.loginAccess : {};\n  const features = isRecord(raw.features) ? raw.features : {};\n  const integrations = isRecord(raw.integrations) ? raw.integrations : {};\n\n  return {\n    appName: toStringValue(raw.appName, DEFAULT_SYSTEM_CONFIG.appName),\n    appLogoUrl: toStringValue(raw.appLogoUrl, DEFAULT_SYSTEM_CONFIG.appLogoUrl),\n    maintenanceMode: toBoolean(raw.maintenanceMode, DEFAULT_SYSTEM_CONFIG.maintenanceMode),\n    loginAccess: {\n      formLoginEnabled: toBoolean(\n        loginAccess.formLoginEnabled,\n        DEFAULT_SYSTEM_CONFIG.loginAccess.formLoginEnabled\n      ),\n      googleLoginEnabled: toBoolean(\n        loginAccess.googleLoginEnabled,\n        DEFAULT_SYSTEM_CONFIG.loginAccess.googleLoginEnabled\n      ),\n    },\n    features: {\n      browseTemplateEnabled: toBoolean(\n        features.browseTemplateEnabled,\n        DEFAULT_SYSTEM_CONFIG.features.browseTemplateEnabled\n      ),\n      blogEnabled: toBoolean(features.blogEnabled, DEFAULT_SYSTEM_CONFIG.features.blogEnabled),\n    },\n    integrations: {\n      resendEnabled: toBoolean(\n        integrations.resendEnabled,\n        DEFAULT_SYSTEM_CONFIG.integrations.resendEnabled\n      ),\n      googleOauthEnabled: toBoolean(\n        integrations.googleOauthEnabled,\n        DEFAULT_SYSTEM_CONFIG.integrations.googleOauthEnabled\n      ),\n      publicApiEnabled: toBoolean(\n        integrations.publicApiEnabled,\n        DEFAULT_SYSTEM_CONFIG.integrations.publicApiEnabled\n      ),\n      publicApiKeyHint: toStringValue(\n        integrations.publicApiKeyHint,\n        DEFAULT_SYSTEM_CONFIG.integrations.publicApiKeyHint\n      ),\n    },\n    roleAccess: mergeRoleAccess(raw.roleAccess),\n  };\n}\n\nasync function ensureSuperAdminTablesInner(): Promise<void> {\n  await runD1Query(`\n    CREATE TABLE IF NOT EXISTS super_admin_settings (\n      key TEXT PRIMARY KEY,\n      value_json TEXT NOT NULL,\n      updated_at TEXT NOT NULL\n    );\n  `);\n\n  await runD1Query(`\n    CREATE TABLE IF NOT EXISTS super_admin_audit_logs (\n      id TEXT PRIMARY KEY,\n      actor_email TEXT NOT NULL,\n      action TEXT NOT NULL,\n      target_type TEXT NOT NULL,\n      target_id TEXT,\n      detail_json TEXT,\n      severity TEXT NOT NULL DEFAULT 'INFO',\n      created_at TEXT NOT NULL\n    );\n  `);\n\n  await runD1Query(`\n    CREATE INDEX IF NOT EXISTS idx_super_admin_audit_logs_created\n    ON super_admin_audit_logs(created_at DESC);\n  `);\n\n  await runD1Query(`\n    CREATE TABLE IF NOT EXISTS auth_login_logs (\n      id TEXT PRIMARY KEY,\n      user_id TEXT,\n      email TEXT NOT NULL,\n      success INTEGER NOT NULL,\n      reason TEXT,\n      request_ip TEXT NOT NULL,\n      user_agent TEXT NOT NULL,\n      created_at TEXT NOT NULL\n    );\n  `);\n\n  await runD1Query(`\n    CREATE INDEX IF NOT EXISTS idx_auth_login_logs_email_created\n    ON auth_login_logs(email, created_at DESC);\n  `);\n\n  await runD1Query(`\n    CREATE INDEX IF NOT EXISTS idx_auth_login_logs_success_created\n    ON auth_login_logs(success, created_at DESC);\n  `);\n\n  await runD1Query(`\n    CREATE TABLE IF NOT EXISTS super_admin_backups (\n      id TEXT PRIMARY KEY,\n      snapshot_type TEXT NOT NULL,\n      payload_json TEXT NOT NULL,\n      created_by TEXT NOT NULL,\n      created_at TEXT NOT NULL\n    );\n  `);\n\n  await runD1Query(`\n    CREATE INDEX IF NOT EXISTS idx_super_admin_backups_created\n    ON super_admin_backups(created_at DESC);\n  `);\n}\n\nexport async function ensureSuperAdminTables(): Promise<void> {\n  if (!ensureSuperAdminTablesPromise) {\n    ensureSuperAdminTablesPromise = ensureSuperAdminTablesInner().catch((error) => {\n      ensureSuperAdminTablesPromise = null;\n      throw error;\n    });\n  }\n\n  await ensureSuperAdminTablesPromise;\n}\n\nasync function getSettingValue<T>(key: string, fallback: T): Promise<T> {\n  await ensureSuperAdminTables();\n\n  const rows = await runD1Query<{ value_json: string }>(\n    \"SELECT value_json FROM super_admin_settings WHERE key = ? LIMIT 1\",\n    [key]\n  );\n\n  if (!rows[0]) return fallback;\n\n  try {\n    return JSON.parse(rows[0].value_json) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nasync function setSettingValue(key: string, value: unknown): Promise<void> {\n  await ensureSuperAdminTables();\n  const now = new Date().toISOString();\n  await runD1Query(\n    \"INSERT OR REPLACE INTO super_admin_settings (key, value_json, updated_at) VALUES (?, ?, ?)\",\n    [key, JSON.stringify(value), now]\n  );\n}\n\nexport async function getSystemConfig(options?: { forceRefresh?: boolean }): Promise<SystemConfig> {\n  if (!options?.forceRefresh && cachedSystemConfig && Date.now() < cachedSystemConfig.expiresAt) {\n    return cachedSystemConfig.value;\n  }\n\n  const raw = await getSettingValue<unknown>(\"system_config\", DEFAULT_SYSTEM_CONFIG);\n  const merged = mergeSystemConfig(raw);\n  cachedSystemConfig = {\n    value: merged,\n    expiresAt: Date.now() + SYSTEM_CONFIG_CACHE_TTL_MS,\n  };\n  return merged;\n}\n\nexport async function saveSystemConfig(config: SystemConfig): Promise<SystemConfig> {\n  const merged = mergeSystemConfig(config);\n  await setSettingValue(\"system_config\", merged);\n  cachedSystemConfig = {\n    value: merged,\n    expiresAt: Date.now() + SYSTEM_CONFIG_CACHE_TTL_MS,\n  };\n  return merged;\n}\n\nexport async function canRoleAccessModule(role: AppRole, module: AccessModule): Promise<boolean> {\n  const config = await getSystemConfig();\n  return Boolean(config.roleAccess[role]?.[module]);\n}\n\nexport async function createAuditLog(params: {\n  actorEmail: string;\n  action: string;\n  targetType: string;\n  targetId?: string;\n  detail?: Record<string, unknown>;\n  severity?: \"INFO\" | \"WARN\" | \"CRITICAL\";\n}): Promise<void> {\n  await ensureSuperAdminTables();\n  const now = new Date().toISOString();\n\n  await runD1Query(\n    `INSERT INTO super_admin_audit_logs (\n      id, actor_email, action, target_type, target_id, detail_json, severity, created_at\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n    [\n      crypto.randomUUID(),\n      params.actorEmail.trim().toLowerCase(),\n      params.action,\n      params.targetType,\n      params.targetId ?? null,\n      params.detail ? JSON.stringify(params.detail) : null,\n      params.severity ?? \"INFO\",\n      now,\n    ]\n  );\n}\n\nexport type AuditLogItem = {\n  id: string;\n  actorEmail: string;\n  action: string;\n  targetType: string;\n  targetId: string | null;\n  detail: Record<string, unknown> | null;\n  severity: string;\n  createdAt: string;\n};\n\nexport async function listAuditLogs(limit = 100): Promise<AuditLogItem[]> {\n  await ensureSuperAdminTables();\n  const safeLimit = Number.isFinite(limit) ? Math.min(Math.max(Math.floor(limit), 1), 500) : 100;\n\n  const rows = await runD1Query<AuditLogRow>(\n    `SELECT id, actor_email, action, target_type, target_id, detail_json, severity, created_at\n     FROM super_admin_audit_logs\n     ORDER BY created_at DESC\n     LIMIT ?`,\n    [safeLimit]\n  );\n\n  return rows.map((row) => {\n    let detail: Record<string, unknown> | null = null;\n    if (row.detail_json) {\n      try {\n        const parsed = JSON.parse(row.detail_json) as unknown;\n        detail = isRecord(parsed) ? parsed : null;\n      } catch {\n        detail = null;\n      }\n    }\n\n    return {\n      id: row.id,\n      actorEmail: row.actor_email,\n      action: row.action,\n      targetType: row.target_type,\n      targetId: row.target_id,\n      detail,\n      severity: row.severity,\n      createdAt: row.created_at,\n    };\n  });\n}\n\nexport async function createLoginLog(params: {\n  email: string;\n  success: boolean;\n  requestIp: string;\n  userAgent: string;\n  reason?: string;\n  userId?: string;\n}): Promise<void> {\n  await ensureSuperAdminTables();\n  const now = new Date().toISOString();\n\n  await runD1Query(\n    `INSERT INTO auth_login_logs (\n      id, user_id, email, success, reason, request_ip, user_agent, created_at\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n    [\n      crypto.randomUUID(),\n      params.userId ?? null,\n      params.email.trim().toLowerCase(),\n      params.success ? 1 : 0,\n      params.reason?.trim() || null,\n      params.requestIp,\n      params.userAgent,\n      now,\n    ]\n  );\n}\n\nexport type LoginLogItem = {\n  id: string;\n  userId: string | null;\n  email: string;\n  success: boolean;\n  reason: string | null;\n  requestIp: string;\n  userAgent: string;\n  createdAt: string;\n};\n\nexport async function listLoginLogs(limit = 100): Promise<LoginLogItem[]> {\n  await ensureSuperAdminTables();\n  const safeLimit = Number.isFinite(limit) ? Math.min(Math.max(Math.floor(limit), 1), 500) : 100;\n\n  const rows = await runD1Query<LoginLogRow>(\n    `SELECT id, user_id, email, success, reason, request_ip, user_agent, created_at\n     FROM auth_login_logs\n     ORDER BY created_at DESC\n     LIMIT ?`,\n    [safeLimit]\n  );\n\n  return rows.map((row) => ({\n    id: row.id,\n    userId: row.user_id,\n    email: row.email,\n    success: row.success === 1,\n    reason: row.reason,\n    requestIp: row.request_ip,\n    userAgent: row.user_agent,\n    createdAt: row.created_at,\n  }));\n}\n\nexport type SuspiciousActivityItem = {\n  email: string;\n  failedAttempts: number;\n  firstAttemptAt: string;\n  lastAttemptAt: string;\n};\n\nexport async function listSuspiciousActivities(): Promise<SuspiciousActivityItem[]> {\n  await ensureSuperAdminTables();\n  const cutoffIso = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n\n  const rows = await runD1Query<{\n    email: string;\n    failed_attempts: number;\n    first_attempt_at: string;\n    last_attempt_at: string;\n  }>(\n    `SELECT email,\n            COUNT(*) AS failed_attempts,\n            MIN(created_at) AS first_attempt_at,\n            MAX(created_at) AS last_attempt_at\n     FROM auth_login_logs\n     WHERE success = 0\n       AND created_at >= ?\n     GROUP BY email\n     HAVING COUNT(*) >= 5\n     ORDER BY failed_attempts DESC, last_attempt_at DESC\n     LIMIT 100`,\n    [cutoffIso]\n  );\n\n  return rows.map((row) => ({\n    email: row.email,\n    failedAttempts: row.failed_attempts,\n    firstAttemptAt: row.first_attempt_at,\n    lastAttemptAt: row.last_attempt_at,\n  }));\n}\n\nexport type DataBackupItem = {\n  id: string;\n  snapshotType: string;\n  payload: Record<string, unknown>;\n  createdBy: string;\n  createdAt: string;\n};\n\nexport type DataBackupMetaItem = {\n  id: string;\n  snapshotType: string;\n  createdBy: string;\n  createdAt: string;\n};\n\nexport async function createDataBackup(params: {\n  snapshotType: string;\n  payload: Record<string, unknown>;\n  createdBy: string;\n}): Promise<DataBackupItem> {\n  await ensureSuperAdminTables();\n  const id = crypto.randomUUID();\n  const now = new Date().toISOString();\n\n  await runD1Query(\n    `INSERT INTO super_admin_backups (id, snapshot_type, payload_json, created_by, created_at)\n     VALUES (?, ?, ?, ?, ?)`,\n    [id, params.snapshotType, JSON.stringify(params.payload), params.createdBy, now]\n  );\n\n  return {\n    id,\n    snapshotType: params.snapshotType,\n    payload: params.payload,\n    createdBy: params.createdBy,\n    createdAt: now,\n  };\n}\n\nexport async function listDataBackups(limit = 30): Promise<DataBackupItem[]> {\n  await ensureSuperAdminTables();\n  const safeLimit = Number.isFinite(limit) ? Math.min(Math.max(Math.floor(limit), 1), 200) : 30;\n\n  const rows = await runD1Query<BackupRow>(\n    `SELECT id, snapshot_type, payload_json, created_by, created_at\n     FROM super_admin_backups\n     ORDER BY created_at DESC\n     LIMIT ?`,\n    [safeLimit]\n  );\n\n  return rows.map((row) => {\n    let payload: Record<string, unknown> = {};\n    try {\n      const parsed = JSON.parse(row.payload_json) as unknown;\n      payload = isRecord(parsed) ? parsed : {};\n    } catch {\n      payload = {};\n    }\n\n    return {\n      id: row.id,\n      snapshotType: row.snapshot_type,\n      payload,\n      createdBy: row.created_by,\n      createdAt: row.created_at,\n    };\n  });\n}\n\nexport async function listDataBackupMeta(limit = 30): Promise<DataBackupMetaItem[]> {\n  await ensureSuperAdminTables();\n  const safeLimit = Number.isFinite(limit) ? Math.min(Math.max(Math.floor(limit), 1), 200) : 30;\n\n  const rows = await runD1Query<{\n    id: string;\n    snapshot_type: string;\n    created_by: string;\n    created_at: string;\n  }>(\n    `SELECT id, snapshot_type, created_by, created_at\n     FROM super_admin_backups\n     ORDER BY created_at DESC\n     LIMIT ?`,\n    [safeLimit]\n  );\n\n  return rows.map((row) => ({\n    id: row.id,\n    snapshotType: row.snapshot_type,\n    createdBy: row.created_by,\n    createdAt: row.created_at,\n  }));\n}\n\nexport async function getDataBackupById(backupId: string): Promise<DataBackupItem | null> {\n  await ensureSuperAdminTables();\n\n  const rows = await runD1Query<BackupRow>(\n    `SELECT id, snapshot_type, payload_json, created_by, created_at\n     FROM super_admin_backups\n     WHERE id = ?\n     LIMIT 1`,\n    [backupId]\n  );\n\n  if (!rows[0]) return null;\n\n  let payload: Record<string, unknown> = {};\n  try {\n    const parsed = JSON.parse(rows[0].payload_json) as unknown;\n    payload = isRecord(parsed) ? parsed : {};\n  } catch {\n    payload = {};\n  }\n\n  return {\n    id: rows[0].id,\n    snapshotType: rows[0].snapshot_type,\n    payload,\n    createdBy: rows[0].created_by,\n    createdAt: rows[0].created_at,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { getRoleFromUser } from \"@/lib/adminAccess\";\nimport { isAuthUserSessionValid } from \"@/lib/authSession\";\nimport { AUTH_COOKIE_NAME, decodeAuthUser } from \"@/lib/authCookie\";\nimport {\n  canAccessAdminPage,\n  canAccessSuperAdminPage,\n  canAccessTemplateManagerPage,\n} from \"@/lib/roles\";\nimport { canRoleAccessModule } from \"@/lib/superAdminDb\";\nimport { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\n\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n  const needsRoleCheck =\n    pathname.startsWith(\"/admin\") ||\n    pathname.startsWith(\"/admin-pengelola\") ||\n    pathname.startsWith(\"/super-admin\");\n\n  if (needsRoleCheck) {\n    const cookieValue = request.cookies.get(AUTH_COOKIE_NAME)?.value;\n    const user = decodeAuthUser(cookieValue);\n    if (!user) {\n      const url = request.nextUrl.clone();\n      url.pathname = \"/signup\";\n      url.searchParams.set(\"auth\", \"required\");\n      return NextResponse.redirect(url);\n    }\n\n    try {\n      const validSession = await isAuthUserSessionValid({\n        email: user.email,\n        sessionIssuedAt: user.sessionIssuedAt,\n      });\n      if (!validSession) {\n        const url = request.nextUrl.clone();\n        url.pathname = \"/login\";\n        url.searchParams.set(\"auth\", \"expired\");\n        const response = NextResponse.redirect(url);\n        response.cookies.delete(AUTH_COOKIE_NAME);\n        return response;\n      }\n    } catch {\n      // fallback to cookie-only check when DB unavailable\n    }\n\n    const role = getRoleFromUser(user);\n    let allowed =\n      (pathname.startsWith(\"/admin-pengelola\") && canAccessTemplateManagerPage(role)) ||\n      (pathname.startsWith(\"/super-admin\") && canAccessSuperAdminPage(role)) ||\n      (pathname.startsWith(\"/admin\") &&\n        !pathname.startsWith(\"/admin-pengelola\") &&\n        canAccessAdminPage(role));\n\n    if (allowed) {\n      const module = pathname.startsWith(\"/admin-pengelola\")\n        ? \"templateManagerPage\"\n        : pathname.startsWith(\"/super-admin\")\n          ? \"superAdminPage\"\n          : \"adminPage\";\n\n      try {\n        allowed = await canRoleAccessModule(role, module);\n      } catch {\n        // fallback to static role checks if dynamic policy fails\n      }\n    }\n\n    if (!allowed) {\n      const url = request.nextUrl.clone();\n      url.pathname = \"/browse-template\";\n      url.searchParams.set(\"admin\", \"forbidden\");\n      return NextResponse.redirect(url);\n    }\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/admin/:path*\", \"/admin-pengelola/:path*\", \"/super-admin/:path*\"],\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AAKA;AACA;AAAA;;;;;;;AAGO,eAAe,WAAW,OAAoB;IACnD,MAAM,WAAW,QAAQ,OAAO,CAAC,QAAQ;IACzC,MAAM,iBACJ,SAAS,UAAU,CAAC,aACpB,SAAS,UAAU,CAAC,uBACpB,SAAS,UAAU,CAAC;IAEtB,IAAI,gBAAgB;QAClB,MAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,CAAC,6IAAgB,GAAG;QAC3D,MAAM,OAAO,IAAA,2IAAc,EAAC;QAC5B,IAAI,CAAC,MAAM;YACT,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;YACjC,IAAI,QAAQ,GAAG;YACf,IAAI,YAAY,CAAC,GAAG,CAAC,QAAQ;YAC7B,OAAO,gMAAY,CAAC,QAAQ,CAAC;QAC/B;QAEA,IAAI;YACF,MAAM,eAAe,MAAM,IAAA,oJAAsB,EAAC;gBAChD,OAAO,KAAK,KAAK;gBACjB,iBAAiB,KAAK,eAAe;YACvC;YACA,IAAI,CAAC,cAAc;gBACjB,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;gBACjC,IAAI,QAAQ,GAAG;gBACf,IAAI,YAAY,CAAC,GAAG,CAAC,QAAQ;gBAC7B,MAAM,WAAW,gMAAY,CAAC,QAAQ,CAAC;gBACvC,SAAS,OAAO,CAAC,MAAM,CAAC,6IAAgB;gBACxC,OAAO;YACT;QACF,EAAE,OAAM;QACN,oDAAoD;QACtD;QAEA,MAAM,OAAO,IAAA,6IAAe,EAAC;QAC7B,IAAI,UACF,AAAC,SAAS,UAAU,CAAC,uBAAuB,IAAA,oJAA4B,EAAC,SACxE,SAAS,UAAU,CAAC,mBAAmB,IAAA,+IAAuB,EAAC,SAC/D,SAAS,UAAU,CAAC,aACnB,CAAC,SAAS,UAAU,CAAC,uBACrB,IAAA,0IAAkB,EAAC;QAEvB,IAAI,SAAS;YACX,MAAM,SAAS,SAAS,UAAU,CAAC,sBAC/B,wBACA,SAAS,UAAU,CAAC,kBAClB,mBACA;YAEN,IAAI;gBACF,UAAU,MAAM,IAAA,kJAAmB,EAAC,MAAM;YAC5C,EAAE,OAAM;YACN,yDAAyD;YAC3D;QACF;QAEA,IAAI,CAAC,SAAS;YACZ,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;YACjC,IAAI,QAAQ,GAAG;YACf,IAAI,YAAY,CAAC,GAAG,CAAC,SAAS;YAC9B,OAAO,gMAAY,CAAC,QAAQ,CAAC;QAC/B;IACF;IAEA,OAAO,gMAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAiB;QAA2B;KAAsB;AAC9E"}}]
}