{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/esm/lib/is-app-route-route.js","turbopack:///[project]/node_modules/next/dist/esm/lib/metadata/is-metadata-route.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/page-path/normalize-path-sep.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js","turbopack:///[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js","turbopack:///[project]/node_modules/next/dist/esm/lib/framework/boundary-constants.js","turbopack:///[project]/node_modules/next/dist/esm/server/lib/clone-response.js","turbopack:///[project]/node_modules/next/dist/esm/server/lib/dedupe-fetch.js","turbopack:///[project]/node_modules/next/dist/esm/server/lib/patch-fetch.js","turbopack:///[project]/node_modules/next/dist/esm/lib/picocolors.js","turbopack:///[project]/node_modules/next/dist/esm/build/output/log.js","turbopack:///[project]/node_modules/next/dist/compiled/string-hash/index.js","turbopack:///[project]/node_modules/next/dist/src/lib/format-server-error.ts","turbopack:///[project]/node_modules/next/dist/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-error.js","turbopack:///[project]/node_modules/next/dist/esm/lib/error-telemetry-utils.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/is-next-router-error.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/create-error-handler.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/is-plain-object.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/react-large-shell-error.js","turbopack:///[project]/node_modules/next/dist/esm/lib/is-error.js","turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-async-storage.external.ts","turbopack:///[project]/node_modules/next/dist/src/shared/lib/utils/reflect-utils.ts","turbopack:///[project]/node_modules/next/dist/esm/server/request/params.js","turbopack:///[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/dynamic-access-async-storage.external.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/utils.js","turbopack:///[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js"],"sourcesContent":["export function isAppRouteRoute(route) {\n    return route.endsWith('/route');\n}\n\n//# sourceMappingURL=is-app-route-route.js.map","import { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep';\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\nimport { isAppRouteRoute } from '../is-app-route-route';\nexport const STATIC_METADATA_IMAGES = {\n    icon: {\n        filename: 'icon',\n        extensions: [\n            'ico',\n            'jpg',\n            'jpeg',\n            'png',\n            'svg'\n        ]\n    },\n    apple: {\n        filename: 'apple-icon',\n        extensions: [\n            'jpg',\n            'jpeg',\n            'png'\n        ]\n    },\n    favicon: {\n        filename: 'favicon',\n        extensions: [\n            'ico'\n        ]\n    },\n    openGraph: {\n        filename: 'opengraph-image',\n        extensions: [\n            'jpg',\n            'jpeg',\n            'png',\n            'gif'\n        ]\n    },\n    twitter: {\n        filename: 'twitter-image',\n        extensions: [\n            'jpg',\n            'jpeg',\n            'png',\n            'gif'\n        ]\n    }\n};\n// Match routes that are metadata routes, e.g. /sitemap.xml, /favicon.<ext>, /<icon>.<ext>, etc.\n// TODO-METADATA: support more metadata routes with more extensions\nexport const DEFAULT_METADATA_ROUTE_EXTENSIONS = [\n    'js',\n    'jsx',\n    'ts',\n    'tsx'\n];\n// Match the file extension with the dynamic multi-routes extensions\n// e.g. ([xml, js], null) -> can match `/sitemap.xml/route`, `sitemap.js/route`\n// e.g. ([png], [ts]) -> can match `/opengrapg-image.png`, `/opengraph-image.ts`\nexport const getExtensionRegexString = (staticExtensions, dynamicExtensions)=>{\n    // If there's no possible multi dynamic routes, will not match any <name>[].<ext> files\n    if (!dynamicExtensions || dynamicExtensions.length === 0) {\n        return `(\\\\.(?:${staticExtensions.join('|')}))`;\n    }\n    return `(?:\\\\.(${staticExtensions.join('|')})|(\\\\.(${dynamicExtensions.join('|')})))`;\n};\n/**\n * Determine if the file is a metadata route file entry\n * @param appDirRelativePath the relative file path to app/\n * @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']\n * @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension\n * @returns if the file is a metadata route file\n */ export function isMetadataRouteFile(appDirRelativePath, pageExtensions, strictlyMatchExtensions) {\n    // End with the extension or optional to have the extension\n    // When strictlyMatchExtensions is true, it's used for match file path;\n    // When strictlyMatchExtensions, the dynamic extension is skipped but\n    // static extension is kept, which is usually used for matching route path.\n    const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$';\n    // Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.\n    const variantsMatcher = '\\\\d?';\n    // The -\\w{6} is the suffix that normalized from group routes;\n    const groupSuffix = strictlyMatchExtensions ? '' : '(-\\\\w{6})?';\n    const suffixMatcher = `${variantsMatcher}${groupSuffix}`;\n    const metadataRouteFilesRegex = [\n        new RegExp(`^[\\\\\\\\/]robots${getExtensionRegexString(pageExtensions.concat('txt'), null)}${trailingMatcher}`),\n        new RegExp(`^[\\\\\\\\/]manifest${getExtensionRegexString(pageExtensions.concat('webmanifest', 'json'), null)}${trailingMatcher}`),\n        new RegExp(`^[\\\\\\\\/]favicon\\\\.ico$`),\n        new RegExp(`[\\\\\\\\/]sitemap${getExtensionRegexString([\n            'xml'\n        ], pageExtensions)}${trailingMatcher}`),\n        new RegExp(`[\\\\\\\\/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(STATIC_METADATA_IMAGES.icon.extensions, pageExtensions)}${trailingMatcher}`),\n        new RegExp(`[\\\\\\\\/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(STATIC_METADATA_IMAGES.apple.extensions, pageExtensions)}${trailingMatcher}`),\n        new RegExp(`[\\\\\\\\/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(STATIC_METADATA_IMAGES.openGraph.extensions, pageExtensions)}${trailingMatcher}`),\n        new RegExp(`[\\\\\\\\/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(STATIC_METADATA_IMAGES.twitter.extensions, pageExtensions)}${trailingMatcher}`)\n    ];\n    const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath);\n    const matched = metadataRouteFilesRegex.some((r)=>r.test(normalizedAppDirRelativePath));\n    return matched;\n}\n// Check if the route is a static metadata route, with /route suffix\n// e.g. /favicon.ico/route, /icon.png/route, etc.\n// But skip the text routes like robots.txt since they might also be dynamic.\n// Checking route path is not enough to determine if text routes is dynamic.\nexport function isStaticMetadataRoute(route) {\n    // extract ext with regex\n    const pathname = route.replace(/\\/route$/, '');\n    const matched = isAppRouteRoute(route) && isMetadataRouteFile(pathname, [], true) && // These routes can either be built by static or dynamic entrypoints,\n    // so we assume they're dynamic\n    pathname !== '/robots.txt' && pathname !== '/manifest.webmanifest' && !pathname.endsWith('/sitemap.xml');\n    return matched;\n}\n/**\n * Determine if a page or pathname is a metadata page.\n *\n * The input is a page or pathname, which can be with or without page suffix /foo/page or /foo.\n * But it will not contain the /route suffix.\n *\n * .e.g\n * /robots -> true\n * /sitemap -> true\n * /foo -> false\n */ export function isMetadataPage(page) {\n    const matched = !isAppRouteRoute(page) && isMetadataRouteFile(page, [], false);\n    return matched;\n}\n/*\n * Determine if a Next.js route is a metadata route.\n * `route` will has a route suffix.\n *\n * e.g.\n * /app/robots/route -> true\n * /robots/route -> true\n * /sitemap/[__metadata_id__]/route -> true\n * /app/sitemap/page -> false\n * /icon-a102f4/route -> true\n */ export function isMetadataRoute(route) {\n    let page = normalizeAppPath(route).replace(/^\\/?app\\//, '')// Remove the dynamic route id\n    .replace('/[__metadata_id__]', '')// Remove the /route suffix\n    .replace(/\\/route$/, '');\n    if (page[0] !== '/') page = '/' + page;\n    const matched = isAppRouteRoute(route) && isMetadataRouteFile(page, [], false);\n    return matched;\n}\n\n//# sourceMappingURL=is-metadata-route.js.map","/**\n * For a given page path, this function ensures that there is no backslash\n * escaping slashes in the path. Example:\n *  - `foo\\/bar\\/baz` -> `foo/bar/baz`\n */ export function normalizePathSep(path) {\n    return path.replace(/\\\\/g, '/');\n}\n\n//# sourceMappingURL=normalize-path-sep.js.map","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nexport class StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nexport function isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\n\n//# sourceMappingURL=static-generation-bailout.js.map","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nexport class DynamicServerError extends Error {\n    constructor(description){\n        super(\"Dynamic server usage: \" + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nexport function isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\n\n//# sourceMappingURL=hooks-server-context.js.map","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { getRuntimeStagePromise, workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { METADATA_BOUNDARY_NAME, VIEWPORT_BOUNDARY_NAME, OUTLET_BOUNDARY_NAME, ROOT_LAYOUT_BOUNDARY_NAME } from '../../lib/framework/boundary-constants';\nimport { scheduleOnNextTick } from '../../lib/scheduler';\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nconst hasPostpone = typeof React.unstable_postpone === 'function';\nexport function createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicErrorWithStack: null\n    };\n}\nexport function createDynamicValidationState() {\n    return {\n        hasSuspenseAboveBody: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasAllowedDynamic: false,\n        dynamicErrors: []\n    };\n}\nexport function getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */ export function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'cache':\n            case 'unstable-cache':\n                // Inside cache scopes, marking a scope as dynamic has no effect,\n                // because the outer cache scope creates a cache boundary. This is\n                // subtly different from reading a dynamic data source, which is\n                // forbidden inside a cache scope.\n                return;\n            case 'private-cache':\n                // A private cache scope is already dynamic by definition.\n                return;\n            case 'prerender-legacy':\n            case 'prerender-ppr':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-ppr':\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            case 'prerender-legacy':\n                workUnitStore.revalidate = 0;\n                // We aren't prerendering, but we are generating a static page. We need\n                // to bail out of static generation.\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E550\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            case 'request':\n                if (process.env.NODE_ENV !== 'production') {\n                    workUnitStore.usedDynamic = true;\n                }\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */ export function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */ export function trackDynamicDataInDynamicRender(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'cache':\n        case 'unstable-cache':\n            // Inside cache scopes, marking a scope as dynamic has no effect,\n            // because the outer cache scope creates a cache boundary. This is\n            // subtly different from reading a dynamic data source, which is\n            // forbidden inside a cache scope.\n            return;\n        case 'private-cache':\n            // A private cache scope is already dynamic by definition.\n            return;\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n        case 'prerender-client':\n            break;\n        case 'request':\n            if (process.env.NODE_ENV !== 'production') {\n                workUnitStore.usedDynamic = true;\n            }\n            break;\n        default:\n            workUnitStore;\n    }\n}\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n}\nexport function trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of prerender mode\n    requestStore.prerenderPhase = false;\n}\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */ export function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const prerenderSignal = prerenderStore.controller.signal;\n    if (prerenderSignal.aborted === false) {\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\n        // the error object when it isn't relevant to the aborting of the prerender however\n        // since we need the throw semantics regardless of whether we abort it is easier to land\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n        // to ideal implementation\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n        // It is important that we set this tracking value after aborting. Aborts are executed\n        // synchronously except for the case where you abort during render itself. By setting this\n        // value late we can use it to determine if any of the aborted tasks are the task that\n        // called the sync IO expression in the first place.\n        const dynamicTracking = prerenderStore.dynamicTracking;\n        if (dynamicTracking) {\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            }\n        }\n    }\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */ export function warnOnSyncDynamicError(dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack) {\n        // the server did something sync dynamic, likely\n        // leading to an early termination of the prerender.\n        console.error(dynamicTracking.syncDynamicErrorWithStack);\n    }\n}\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;\nexport function Postpone({ reason, route }) {\n    const prerenderStore = workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nexport function postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    React.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nexport function isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nexport function isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nexport function accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nexport function consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nexport function formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */ export function createRenderInBrowserAbortSignal() {\n    const controller = new AbortController();\n    controller.abort(Object.defineProperty(new BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\n        value: \"E721\",\n        enumerable: false,\n        configurable: true\n    }));\n    return controller.signal;\n}\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */ export function createHangingInputAbortSignal(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'prerender':\n        case 'prerender-runtime':\n            const controller = new AbortController();\n            if (workUnitStore.cacheSignal) {\n                // If we have a cacheSignal it means we're in a prospective render. If\n                // the input we're waiting on is coming from another cache, we do want\n                // to wait for it so that we can resolve this cache entry too.\n                workUnitStore.cacheSignal.inputReady().then(()=>{\n                    controller.abort();\n                });\n            } else {\n                // Otherwise we're in the final render and we should already have all\n                // our caches filled.\n                // If the prerender uses stages, we have wait until the runtime stage,\n                // at which point all runtime inputs will be resolved.\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\n                //  even though they'd resolve in the next task.)\n                //\n                // We might still be waiting on some microtasks so we\n                // wait one tick before giving up. When we give up, we still want to\n                // render the content of this cache as deeply as we can so that we can\n                // suspend as deeply as possible in the tree or not at all if we don't\n                // end up waiting for the input.\n                const runtimeStagePromise = getRuntimeStagePromise(workUnitStore);\n                if (runtimeStagePromise) {\n                    runtimeStagePromise.then(()=>scheduleOnNextTick(()=>controller.abort()));\n                } else {\n                    scheduleOnNextTick(()=>controller.abort());\n                }\n            }\n            return controller.signal;\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            return undefined;\n        default:\n            workUnitStore;\n    }\n}\nexport function annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function useDynamicRouteParams(expression) {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore && workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-client':\n            case 'prerender':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        // We are in a prerender with cacheComponents semantics. We are going to\n                        // hang here and never resolve. This will cause the currently\n                        // rendering component to effectively be a dynamic hole.\n                        React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\n                    }\n                    break;\n                }\n            case 'prerender-ppr':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                    }\n                    break;\n                }\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E771\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E745\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-legacy':\n            case 'request':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nexport function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n        dynamicValidation.hasAllowedDynamic = true;\n        dynamicValidation.hasSuspenseAboveBody = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        // this error had a Suspense boundary above it so we don't need to report it as a source\n        // of disallowed\n        dynamicValidation.hasAllowedDynamic = true;\n        return;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        // This task was the task that called the sync error.\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\n        return;\n    } else {\n        const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\n    const ownerStack = process.env.NODE_ENV !== 'production' && React.captureOwnerStack ? React.captureOwnerStack() : null;\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\n    return error;\n}\nexport var PreludeState = /*#__PURE__*/ function(PreludeState) {\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\n    return PreludeState;\n}({});\nexport function logDisallowedDynamicError(workStore, error) {\n    console.error(error);\n    if (!workStore.dev) {\n        if (workStore.hasReadableErrorStacks) {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\n        } else {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\n        }\n    }\n}\nexport function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\n    if (prelude !== 0) {\n        if (dynamicValidation.hasSuspenseAboveBody) {\n            // This route has opted into allowing fully dynamic rendering\n            // by including a Suspense boundary above the body. In this case\n            // a lack of a shell is not considered disallowed so we simply return\n            return;\n        }\n        if (serverDynamic.syncDynamicErrorWithStack) {\n            // There is no shell and the server did something sync dynamic likely\n            // leading to an early termination of the prerender before the shell\n            // could be completed. We terminate the build/validating render.\n            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\n            throw new StaticGenBailoutError();\n        }\n        // We didn't have any sync bailouts but there may be user code which\n        // blocked the root. We would have captured these during the prerender\n        // and can log them here and then terminate the build/validating render\n        const dynamicErrors = dynamicValidation.dynamicErrors;\n        if (dynamicErrors.length > 0) {\n            for(let i = 0; i < dynamicErrors.length; i++){\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\n            }\n            throw new StaticGenBailoutError();\n        }\n        // If we got this far then the only other thing that could be blocking\n        // the root is dynamic Viewport. If this is dynamic then\n        // you need to opt into that by adding a Suspense boundary above the body\n        // to indicate your are ok with fully dynamic rendering.\n        if (dynamicValidation.hasDynamicViewport) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\n            throw new StaticGenBailoutError();\n        }\n        if (prelude === 1) {\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\n            // We still adhere to the constraint that you must produce a shell but invite the\n            // user to report this as a bug in Next.js.\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\n            throw new StaticGenBailoutError();\n        }\n    } else {\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\n            throw new StaticGenBailoutError();\n        }\n    }\n}\nexport function delayUntilRuntimeStage(prerenderStore, result) {\n    if (prerenderStore.runtimeStagePromise) {\n        return prerenderStore.runtimeStagePromise.then(()=>result);\n    }\n    return result;\n}\n\n//# sourceMappingURL=dynamic-rendering.js.map","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';\n/** An error that should be thrown when we want to bail out to client-side rendering. */ export class BailoutToCSRError extends Error {\n    constructor(reason){\n        super(\"Bail out to client-side rendering: \" + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;\n    }\n}\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */ export function isBailoutToCSRError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === BAILOUT_TO_CSR;\n}\n\n//# sourceMappingURL=bailout-to-csr.js.map","export function isHangingPromiseRejectionError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n    constructor(route, expression){\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n    }\n}\nconst abortListenersBySignal = new WeakMap();\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */ export function makeHangingPromise(signal, route, expression) {\n    if (signal.aborted) {\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\n    } else {\n        const hangingPromise = new Promise((_, reject)=>{\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\n            let currentListeners = abortListenersBySignal.get(signal);\n            if (currentListeners) {\n                currentListeners.push(boundRejection);\n            } else {\n                const listeners = [\n                    boundRejection\n                ];\n                abortListenersBySignal.set(signal, listeners);\n                signal.addEventListener('abort', ()=>{\n                    for(let i = 0; i < listeners.length; i++){\n                        listeners[i]();\n                    }\n                }, {\n                    once: true\n                });\n            }\n        });\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\n        hangingPromise.catch(ignoreReject);\n        return hangingPromise;\n    }\n}\nfunction ignoreReject() {}\nexport function makeDevtoolsIOAwarePromise(underlying) {\n    // in React DevTools if we resolve in a setTimeout we will observe\n    // the promise resolution as something that can suspend a boundary or root.\n    return new Promise((resolve)=>{\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n        setTimeout(()=>{\n            resolve(underlying);\n        }, 0);\n    });\n}\n\n//# sourceMappingURL=dynamic-rendering-utils.js.map","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__';\n\n//# sourceMappingURL=boundary-constants.js.map","const noop = ()=>{};\nlet registry;\nif (globalThis.FinalizationRegistry) {\n    registry = new FinalizationRegistry((weakRef)=>{\n        const stream = weakRef.deref();\n        if (stream && !stream.locked) {\n            stream.cancel('Response object has been garbage collected').then(noop);\n        }\n    });\n}\n/**\n * Clones a response by teeing the body so we can return two independent\n * ReadableStreams from it. This avoids the bug in the undici library around\n * response cloning.\n *\n * After cloning, the original response's body will be consumed and closed.\n *\n * @see https://github.com/vercel/next.js/pull/73274\n *\n * @param original - The original response to clone.\n * @returns A tuple containing two independent clones of the original response.\n */ export function cloneResponse(original) {\n    // If the response has no body, then we can just return the original response\n    // twice because it's immutable.\n    if (!original.body) {\n        return [\n            original,\n            original\n        ];\n    }\n    const [body1, body2] = original.body.tee();\n    const cloned1 = new Response(body1, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned1, 'url', {\n        value: original.url,\n        // How the original response.url behaves\n        configurable: true,\n        enumerable: true,\n        writable: false\n    });\n    // The Fetch Standard allows users to skip consuming the response body by\n    // relying on garbage collection to release connection resources.\n    // https://github.com/nodejs/undici?tab=readme-ov-file#garbage-collection\n    //\n    // To cancel the stream you then need to cancel both resulting branches.\n    // Teeing a stream will generally lock it for the duration, preventing other\n    // readers from locking it.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee\n    // cloned2 is stored in a react cache and cloned for subsequent requests.\n    // It is the original request, and is is garbage collected by a\n    // FinalizationRegistry in Undici, but since we're tee-ing the stream\n    // ourselves, we need to cancel clone1's stream (the response returned from\n    // our dedupe fetch) when clone1 is reclaimed, otherwise we leak memory.\n    if (registry && cloned1.body) {\n        registry.register(cloned1, new WeakRef(cloned1.body));\n    }\n    const cloned2 = new Response(body2, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned2, 'url', {\n        value: original.url,\n        // How the original response.url behaves\n        configurable: true,\n        enumerable: true,\n        writable: false\n    });\n    return [\n        cloned1,\n        cloned2\n    ];\n}\n\n//# sourceMappingURL=clone-response.js.map","/**\n * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js\n */ import * as React from 'react';\nimport { cloneResponse } from './clone-response';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nconst simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n;\nfunction generateCacheKey(request) {\n    // We pick the fields that goes into the key used to dedupe requests.\n    // We don't include the `cache` field, because we end up using whatever\n    // caching resulted from the first request.\n    // Notably we currently don't consider non-standard (or future) options.\n    // This might not be safe. TODO: warn for non-standard extensions differing.\n    // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n    return JSON.stringify([\n        request.method,\n        Array.from(request.headers.entries()),\n        request.mode,\n        request.redirect,\n        request.credentials,\n        request.referrer,\n        request.referrerPolicy,\n        request.integrity\n    ]);\n}\nexport function createDedupeFetch(originalFetch) {\n    const getCacheEntries = React.cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key\n    (url)=>[]);\n    return function dedupeFetch(resource, options) {\n        if (options && options.signal) {\n            // If we're passed a signal, then we assume that\n            // someone else controls the lifetime of this object and opts out of\n            // caching. It's effectively the opt-out mechanism.\n            // Ideally we should be able to check this on the Request but\n            // it always gets initialized with its own signal so we don't\n            // know if it's supposed to override - unless we also override the\n            // Request constructor.\n            return originalFetch(resource, options);\n        }\n        // Normalize the Request\n        let url;\n        let cacheKey;\n        if (typeof resource === 'string' && !options) {\n            // Fast path.\n            cacheKey = simpleCacheKey;\n            url = resource;\n        } else {\n            // Normalize the request.\n            // if resource is not a string or a URL (its an instance of Request)\n            // then do not instantiate a new Request but instead\n            // reuse the request as to not disturb the body in the event it's a ReadableStream.\n            const request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;\n            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {\n                // We currently don't dedupe requests that might have side-effects. Those\n                // have to be explicitly cached. We assume that the request doesn't have a\n                // body if it's GET or HEAD.\n                // keepalive gets treated the same as if you passed a custom cache signal.\n                return originalFetch(resource, options);\n            }\n            cacheKey = generateCacheKey(request);\n            url = request.url;\n        }\n        const cacheEntries = getCacheEntries(url);\n        for(let i = 0, j = cacheEntries.length; i < j; i += 1){\n            const [key, promise] = cacheEntries[i];\n            if (key === cacheKey) {\n                return promise.then(()=>{\n                    const response = cacheEntries[i][2];\n                    if (!response) throw Object.defineProperty(new InvariantError('No cached response'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E579\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    // We're cloning the response using this utility because there exists\n                    // a bug in the undici library around response cloning. See the\n                    // following pull request for more details:\n                    // https://github.com/vercel/next.js/pull/73274\n                    const [cloned1, cloned2] = cloneResponse(response);\n                    cacheEntries[i][2] = cloned2;\n                    return cloned1;\n                });\n            }\n        }\n        // We pass the original arguments here in case normalizing the Request\n        // doesn't include all the options in this environment.\n        const promise = originalFetch(resource, options);\n        const entry = [\n            cacheKey,\n            promise,\n            null\n        ];\n        cacheEntries.push(entry);\n        return promise.then((response)=>{\n            // We're cloning the response using this utility because there exists\n            // a bug in the undici library around response cloning. See the\n            // following pull request for more details:\n            // https://github.com/vercel/next.js/pull/73274\n            const [cloned1, cloned2] = cloneResponse(response);\n            entry[2] = cloned2;\n            return cloned1;\n        });\n    };\n}\n\n//# sourceMappingURL=dedupe-fetch.js.map","import { AppRenderSpan, NextNodeServerSpan } from './trace/constants';\nimport { getTracer, SpanKind } from './trace/tracer';\nimport { CACHE_ONE_YEAR, INFINITE_CACHE, NEXT_CACHE_TAG_MAX_ITEMS, NEXT_CACHE_TAG_MAX_LENGTH } from '../../lib/constants';\nimport { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupeFetch } from './dedupe-fetch';\nimport { getCacheSignal } from '../app-render/work-unit-async-storage.external';\nimport { CachedRouteKind, IncrementalCacheKind } from '../response-cache';\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\nimport { cloneResponse } from './clone-response';\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\nexport const NEXT_PATCH_SYMBOL = Symbol.for('next-patch');\nfunction isFetchPatched() {\n    return globalThis[NEXT_PATCH_SYMBOL] === true;\n}\nexport function validateRevalidate(revalidateVal, route) {\n    try {\n        let normalizedRevalidate = undefined;\n        if (revalidateVal === false) {\n            normalizedRevalidate = INFINITE_CACHE;\n        } else if (typeof revalidateVal === 'number' && !isNaN(revalidateVal) && revalidateVal > -1) {\n            normalizedRevalidate = revalidateVal;\n        } else if (typeof revalidateVal !== 'undefined') {\n            throw Object.defineProperty(new Error(`Invalid revalidate value \"${revalidateVal}\" on \"${route}\", must be a non-negative number or false`), \"__NEXT_ERROR_CODE\", {\n                value: \"E179\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return normalizedRevalidate;\n    } catch (err) {\n        // handle client component error from attempting to check revalidate value\n        if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n            throw err;\n        }\n        return undefined;\n    }\n}\nexport function validateTags(tags, description) {\n    const validTags = [];\n    const invalidTags = [];\n    for(let i = 0; i < tags.length; i++){\n        const tag = tags[i];\n        if (typeof tag !== 'string') {\n            invalidTags.push({\n                tag,\n                reason: 'invalid type, must be a string'\n            });\n        } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {\n            invalidTags.push({\n                tag,\n                reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`\n            });\n        } else {\n            validTags.push(tag);\n        }\n        if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {\n            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(', '));\n            break;\n        }\n    }\n    if (invalidTags.length > 0) {\n        console.warn(`Warning: invalid tags passed to ${description}: `);\n        for (const { tag, reason } of invalidTags){\n            console.log(`tag: \"${tag}\" ${reason}`);\n        }\n    }\n    return validTags;\n}\nfunction trackFetchMetric(workStore, ctx) {\n    if (!workStore.shouldTrackFetchMetrics) {\n        return;\n    }\n    workStore.fetchMetrics ??= [];\n    workStore.fetchMetrics.push({\n        ...ctx,\n        end: performance.timeOrigin + performance.now(),\n        idx: workStore.nextFetchId || 0\n    });\n}\nasync function createCachedPrerenderResponse(res, cacheKey, incrementalCacheContext, incrementalCache, revalidate, handleUnlock) {\n    // We are prerendering at build time or revalidate time with cacheComponents so we\n    // need to buffer the response so we can guarantee it can be read in a\n    // microtask.\n    const bodyBuffer = await res.arrayBuffer();\n    const fetchedData = {\n        headers: Object.fromEntries(res.headers.entries()),\n        body: Buffer.from(bodyBuffer).toString('base64'),\n        status: res.status,\n        url: res.url\n    };\n    // We can skip setting the serverComponentsHmrCache because we aren't in dev\n    // mode.\n    if (incrementalCacheContext) {\n        await incrementalCache.set(cacheKey, {\n            kind: CachedRouteKind.FETCH,\n            data: fetchedData,\n            revalidate\n        }, incrementalCacheContext);\n    }\n    await handleUnlock();\n    // We return a new Response to the caller.\n    return new Response(bodyBuffer, {\n        headers: res.headers,\n        status: res.status,\n        statusText: res.statusText\n    });\n}\nasync function createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheContext, incrementalCache, serverComponentsHmrCache, revalidate, input, handleUnlock) {\n    // We're cloning the response using this utility because there exists a bug in\n    // the undici library around response cloning. See the following pull request\n    // for more details: https://github.com/vercel/next.js/pull/73274\n    const [cloned1, cloned2] = cloneResponse(res);\n    // We are dynamically rendering including dev mode. We want to return the\n    // response to the caller as soon as possible because it might stream over a\n    // very long time.\n    const cacheSetPromise = cloned1.arrayBuffer().then(async (arrayBuffer)=>{\n        const bodyBuffer = Buffer.from(arrayBuffer);\n        const fetchedData = {\n            headers: Object.fromEntries(cloned1.headers.entries()),\n            body: bodyBuffer.toString('base64'),\n            status: cloned1.status,\n            url: cloned1.url\n        };\n        serverComponentsHmrCache == null ? void 0 : serverComponentsHmrCache.set(cacheKey, fetchedData);\n        if (incrementalCacheContext) {\n            await incrementalCache.set(cacheKey, {\n                kind: CachedRouteKind.FETCH,\n                data: fetchedData,\n                revalidate\n            }, incrementalCacheContext);\n        }\n    }).catch((error)=>console.warn(`Failed to set fetch cache`, input, error)).finally(handleUnlock);\n    const pendingRevalidateKey = `cache-set-${cacheKey}`;\n    workStore.pendingRevalidates ??= {};\n    if (pendingRevalidateKey in workStore.pendingRevalidates) {\n        // there is already a pending revalidate entry that we need to await to\n        // avoid race conditions\n        await workStore.pendingRevalidates[pendingRevalidateKey];\n    }\n    workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(()=>{\n        var _workStore_pendingRevalidates;\n        // If the pending revalidate is not present in the store, then we have\n        // nothing to delete.\n        if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {\n            return;\n        }\n        delete workStore.pendingRevalidates[pendingRevalidateKey];\n    });\n    return cloned2;\n}\nexport function createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {\n    // Create the patched fetch function.\n    const patched = async function fetch(input, init) {\n        var _init_method, _init_next;\n        let url;\n        try {\n            url = new URL(input instanceof Request ? input.url : input);\n            url.username = '';\n            url.password = '';\n        } catch  {\n            // Error caused by malformed URL should be handled by native fetch\n            url = undefined;\n        }\n        const fetchUrl = (url == null ? void 0 : url.href) ?? '';\n        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || 'GET';\n        // Do create a new span trace for internal fetches in the\n        // non-verbose mode.\n        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;\n        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';\n        // We don't track fetch metrics for internal fetches\n        // so it's not critical that we have a start time, as it won't be recorded.\n        // This is to workaround a flaky issue where performance APIs might\n        // not be available and will require follow-up investigation.\n        const fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();\n        const workStore = workAsyncStorage.getStore();\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        // During static generation we track cache reads so we can reason about when they fill\n        let cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null;\n        if (cacheSignal) {\n            cacheSignal.beginRead();\n        }\n        const result = getTracer().trace(isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch, {\n            hideSpan,\n            kind: SpanKind.CLIENT,\n            spanName: [\n                'fetch',\n                method,\n                fetchUrl\n            ].filter(Boolean).join(' '),\n            attributes: {\n                'http.url': fetchUrl,\n                'http.method': method,\n                'net.peer.name': url == null ? void 0 : url.hostname,\n                'net.peer.port': (url == null ? void 0 : url.port) || undefined\n            }\n        }, async ()=>{\n            var _getRequestMeta;\n            // If this is an internal fetch, we should not do any special treatment.\n            if (isInternal) {\n                return originFetch(input, init);\n            }\n            // If the workStore is not available, we can't do any\n            // special treatment of fetch, therefore fallback to the original\n            // fetch implementation.\n            if (!workStore) {\n                return originFetch(input, init);\n            }\n            // We should also fallback to the original fetch implementation if we\n            // are in draft mode, it does not constitute a static generation.\n            if (workStore.isDraftMode) {\n                return originFetch(input, init);\n            }\n            const isRequestInput = input && typeof input === 'object' && typeof input.method === 'string';\n            const getRequestMeta = (field)=>{\n                // If request input is present but init is not, retrieve from input first.\n                const value = init == null ? void 0 : init[field];\n                return value || (isRequestInput ? input[field] : null);\n            };\n            let finalRevalidate = undefined;\n            const getNextField = (field)=>{\n                var _init_next, _init_next1, _input_next;\n                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== 'undefined' ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;\n            };\n            // RequestInit doesn't keep extra fields e.g. next so it's\n            // only available if init is used separate\n            const originalFetchRevalidate = getNextField('revalidate');\n            let currentFetchRevalidate = originalFetchRevalidate;\n            const tags = validateTags(getNextField('tags') || [], `fetch ${input.toString()}`);\n            let revalidateStore;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'prerender':\n                    case 'prerender-runtime':\n                    // TODO: Stop accumulating tags in client prerender. (fallthrough)\n                    case 'prerender-client':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'cache':\n                    case 'private-cache':\n                        revalidateStore = workUnitStore;\n                        break;\n                    case 'request':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            if (revalidateStore) {\n                if (Array.isArray(tags)) {\n                    // Collect tags onto parent caches or parent prerenders.\n                    const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);\n                    for (const tag of tags){\n                        if (!collectedTags.includes(tag)) {\n                            collectedTags.push(tag);\n                        }\n                    }\n                }\n            }\n            const implicitTags = workUnitStore == null ? void 0 : workUnitStore.implicitTags;\n            let pageFetchCacheMode = workStore.fetchCache;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'unstable-cache':\n                        // Inside unstable-cache we treat it the same as force-no-store on\n                        // the page.\n                        pageFetchCacheMode = 'force-no-store';\n                        break;\n                    case 'prerender':\n                    case 'prerender-client':\n                    case 'prerender-runtime':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'request':\n                    case 'cache':\n                    case 'private-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            const isUsingNoStore = !!workStore.isUnstableNoStore;\n            let currentFetchCacheConfig = getRequestMeta('cache');\n            let cacheReason = '';\n            let cacheWarning;\n            if (typeof currentFetchCacheConfig === 'string' && typeof currentFetchRevalidate !== 'undefined') {\n                // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.\n                const isConflictingRevalidate = // revalidate: 0 and cache: force-cache\n                currentFetchCacheConfig === 'force-cache' && currentFetchRevalidate === 0 || // revalidate: >0 or revalidate: false and cache: no-store\n                currentFetchCacheConfig === 'no-store' && (currentFetchRevalidate > 0 || currentFetchRevalidate === false);\n                if (isConflictingRevalidate) {\n                    cacheWarning = `Specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`;\n                    currentFetchCacheConfig = undefined;\n                    currentFetchRevalidate = undefined;\n                }\n            }\n            const hasExplicitFetchCacheOptOut = // fetch config itself signals not to cache\n            currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache\n            // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.\n            pageFetchCacheMode === 'force-no-store' || pageFetchCacheMode === 'only-no-store';\n            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n            // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n            // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n            // other configurations.\n            const noFetchConfigAndForceDynamic = !pageFetchCacheMode && !currentFetchCacheConfig && !currentFetchRevalidate && workStore.forceDynamic;\n            if (// force-cache was specified without a revalidate value. We set the revalidate value to false\n            // which will signal the cache to not revalidate\n            currentFetchCacheConfig === 'force-cache' && typeof currentFetchRevalidate === 'undefined') {\n                currentFetchRevalidate = false;\n            } else if (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic) {\n                currentFetchRevalidate = 0;\n            }\n            if (currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store') {\n                cacheReason = `cache: ${currentFetchCacheConfig}`;\n            }\n            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);\n            const _headers = getRequestMeta('headers');\n            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === 'function' ? _headers : new Headers(_headers || {});\n            const hasUnCacheableHeader = initHeaders.get('authorization') || initHeaders.get('cookie');\n            const isUnCacheableMethod = ![\n                'get',\n                'head'\n            ].includes(((_getRequestMeta = getRequestMeta('method')) == null ? void 0 : _getRequestMeta.toLowerCase()) || 'get');\n            /**\n         * We automatically disable fetch caching under the following conditions:\n         * - Fetch cache configs are not set. Specifically:\n         *    - A page fetch cache mode is not set (export const fetchCache=...)\n         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))\n         *      or the fetch cache mode is set to 'default'\n         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))\n         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())\n         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)\n         */ const hasNoExplicitCacheConfig = // eslint-disable-next-line eqeqeq\n            pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq\n            (currentFetchCacheConfig == undefined || // when considering whether to opt into the default \"no-cache\" fetch semantics,\n            // a \"default\" cache config should be treated the same as no cache config\n            currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq\n            currentFetchRevalidate == undefined;\n            let autoNoCache = Boolean((hasUnCacheableHeader || isUnCacheableMethod) && (revalidateStore == null ? void 0 : revalidateStore.revalidate) === 0);\n            let isImplicitBuildTimeCache = false;\n            if (!autoNoCache && hasNoExplicitCacheConfig) {\n                // We don't enable automatic no-cache behavior during build-time\n                // prerendering so that we can still leverage the fetch cache between\n                // export workers.\n                if (workStore.isBuildTimePrerendering) {\n                    isImplicitBuildTimeCache = true;\n                } else {\n                    autoNoCache = true;\n                }\n            }\n            // If we have no cache config, and we're in Dynamic I/O prerendering,\n            // it'll be a dynamic call. We don't have to issue that dynamic call.\n            if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {\n                switch(workUnitStore.type){\n                    case 'prerender':\n                    case 'prerender-runtime':\n                    // While we don't want to do caching in the client scope we know the\n                    // fetch will be dynamic for cacheComponents so we may as well avoid the\n                    // call here. (fallthrough)\n                    case 'prerender-client':\n                        if (cacheSignal) {\n                            cacheSignal.endRead();\n                            cacheSignal = null;\n                        }\n                        return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'request':\n                    case 'cache':\n                    case 'private-cache':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            switch(pageFetchCacheMode){\n                case 'force-no-store':\n                    {\n                        cacheReason = 'fetchCache = force-no-store';\n                        break;\n                    }\n                case 'only-no-store':\n                    {\n                        if (currentFetchCacheConfig === 'force-cache' || typeof finalRevalidate !== 'undefined' && finalRevalidate > 0) {\n                            throw Object.defineProperty(new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E448\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheReason = 'fetchCache = only-no-store';\n                        break;\n                    }\n                case 'only-cache':\n                    {\n                        if (currentFetchCacheConfig === 'no-store') {\n                            throw Object.defineProperty(new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E521\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        break;\n                    }\n                case 'force-cache':\n                    {\n                        if (typeof currentFetchRevalidate === 'undefined' || currentFetchRevalidate === 0) {\n                            cacheReason = 'fetchCache = force-cache';\n                            finalRevalidate = INFINITE_CACHE;\n                        }\n                        break;\n                    }\n                case 'default-cache':\n                case 'default-no-store':\n                case 'auto':\n                case undefined:\n                    break;\n                default:\n                    pageFetchCacheMode;\n            }\n            if (typeof finalRevalidate === 'undefined') {\n                if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n                    finalRevalidate = INFINITE_CACHE;\n                    cacheReason = 'fetchCache = default-cache';\n                } else if (pageFetchCacheMode === 'default-no-store') {\n                    finalRevalidate = 0;\n                    cacheReason = 'fetchCache = default-no-store';\n                } else if (isUsingNoStore) {\n                    finalRevalidate = 0;\n                    cacheReason = 'noStore call';\n                } else if (autoNoCache) {\n                    finalRevalidate = 0;\n                    cacheReason = 'auto no cache';\n                } else {\n                    // TODO: should we consider this case an invariant?\n                    cacheReason = 'auto cache';\n                    finalRevalidate = revalidateStore ? revalidateStore.revalidate : INFINITE_CACHE;\n                }\n            } else if (!cacheReason) {\n                cacheReason = `revalidate: ${finalRevalidate}`;\n            }\n            if (// when force static is configured we don't bail from\n            // `revalidate: 0` values\n            !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR\n            !autoNoCache && // If the revalidate value isn't currently set or the value is less\n            // than the current revalidate value, we should update the revalidate\n            // value.\n            revalidateStore && finalRevalidate < revalidateStore.revalidate) {\n                // If we were setting the revalidate value to 0, we should try to\n                // postpone instead first.\n                if (finalRevalidate === 0) {\n                    if (workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                if (cacheSignal) {\n                                    cacheSignal.endRead();\n                                    cacheSignal = null;\n                                }\n                                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'request':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    markCurrentScopeAsDynamic(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                }\n                // We only want to set the revalidate store's revalidate time if it\n                // was explicitly set for the fetch call, i.e.\n                // originalFetchRevalidate.\n                if (revalidateStore && originalFetchRevalidate === finalRevalidate) {\n                    revalidateStore.revalidate = finalRevalidate;\n                }\n            }\n            const isCacheableRevalidate = typeof finalRevalidate === 'number' && finalRevalidate > 0;\n            let cacheKey;\n            const { incrementalCache } = workStore;\n            let isHmrRefresh = false;\n            let serverComponentsHmrCache;\n            if (workUnitStore) {\n                switch(workUnitStore.type){\n                    case 'request':\n                    case 'cache':\n                    case 'private-cache':\n                        isHmrRefresh = workUnitStore.isHmrRefresh ?? false;\n                        serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache;\n                        break;\n                    case 'prerender':\n                    case 'prerender-client':\n                    case 'prerender-runtime':\n                    case 'prerender-ppr':\n                    case 'prerender-legacy':\n                    case 'unstable-cache':\n                        break;\n                    default:\n                        workUnitStore;\n                }\n            }\n            if (incrementalCache && (isCacheableRevalidate || serverComponentsHmrCache)) {\n                try {\n                    cacheKey = await incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);\n                } catch (err) {\n                    console.error(`Failed to generate cache key for`, input);\n                }\n            }\n            const fetchIdx = workStore.nextFetchId ?? 1;\n            workStore.nextFetchId = fetchIdx + 1;\n            let handleUnlock = ()=>{};\n            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{\n                const requestInputFields = [\n                    'cache',\n                    'credentials',\n                    'headers',\n                    'integrity',\n                    'keepalive',\n                    'method',\n                    'mode',\n                    'redirect',\n                    'referrer',\n                    'referrerPolicy',\n                    'window',\n                    'duplex',\n                    // don't pass through signal when revalidating\n                    ...isStale ? [] : [\n                        'signal'\n                    ]\n                ];\n                if (isRequestInput) {\n                    const reqInput = input;\n                    const reqOptions = {\n                        body: reqInput._ogBody || reqInput.body\n                    };\n                    for (const field of requestInputFields){\n                        // @ts-expect-error custom fields\n                        reqOptions[field] = reqInput[field];\n                    }\n                    input = new Request(reqInput.url, reqOptions);\n                } else if (init) {\n                    const { _ogBody, body, signal, ...otherInput } = init;\n                    init = {\n                        ...otherInput,\n                        body: _ogBody || body,\n                        signal: isStale ? undefined : signal\n                    };\n                }\n                // add metadata to init without editing the original\n                const clonedInit = {\n                    ...init,\n                    next: {\n                        ...init == null ? void 0 : init.next,\n                        fetchType: 'origin',\n                        fetchIdx\n                    }\n                };\n                return originFetch(input, clonedInit).then(async (res)=>{\n                    if (!isStale && fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason: cacheReasonOverride || cacheReason,\n                            cacheStatus: finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',\n                            cacheWarning,\n                            status: res.status,\n                            method: clonedInit.method || 'GET'\n                        });\n                    }\n                    if (res.status === 200 && incrementalCache && cacheKey && (isCacheableRevalidate || serverComponentsHmrCache)) {\n                        const normalizedRevalidate = finalRevalidate >= INFINITE_CACHE ? CACHE_ONE_YEAR : finalRevalidate;\n                        const incrementalCacheConfig = isCacheableRevalidate ? {\n                            fetchCache: true,\n                            fetchUrl,\n                            fetchIdx,\n                            tags,\n                            isImplicitBuildTimeCache\n                        } : undefined;\n                        switch(workUnitStore == null ? void 0 : workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                return createCachedPrerenderResponse(res, cacheKey, incrementalCacheConfig, incrementalCache, normalizedRevalidate, handleUnlock);\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'request':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                            case undefined:\n                                return createCachedDynamicResponse(workStore, res, cacheKey, incrementalCacheConfig, incrementalCache, serverComponentsHmrCache, normalizedRevalidate, input, handleUnlock);\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    // we had response that we determined shouldn't be cached so we return it\n                    // and don't cache it. This also needs to unlock the cache lock we acquired.\n                    await handleUnlock();\n                    return res;\n                }).catch((error)=>{\n                    handleUnlock();\n                    throw error;\n                });\n            };\n            let cacheReasonOverride;\n            let isForegroundRevalidate = false;\n            let isHmrRefreshCache = false;\n            if (cacheKey && incrementalCache) {\n                let cachedFetchData;\n                if (isHmrRefresh && serverComponentsHmrCache) {\n                    cachedFetchData = serverComponentsHmrCache.get(cacheKey);\n                    isHmrRefreshCache = true;\n                }\n                if (isCacheableRevalidate && !cachedFetchData) {\n                    handleUnlock = await incrementalCache.lock(cacheKey);\n                    const entry = workStore.isOnDemandRevalidate ? null : await incrementalCache.get(cacheKey, {\n                        kind: IncrementalCacheKind.FETCH,\n                        revalidate: finalRevalidate,\n                        fetchUrl,\n                        fetchIdx,\n                        tags,\n                        softTags: implicitTags == null ? void 0 : implicitTags.tags\n                    });\n                    if (hasNoExplicitCacheConfig && workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                // We sometimes use the cache to dedupe fetches that do not\n                                // specify a cache configuration. In these cases we want to\n                                // make sure we still exclude them from prerenders if\n                                // cacheComponents is on so we introduce an artificial task boundary\n                                // here.\n                                await waitAtLeastOneReactRenderTask();\n                                break;\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'request':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    if (entry) {\n                        await handleUnlock();\n                    } else {\n                        // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n                        cacheReasonOverride = 'cache-control: no-cache (hard refresh)';\n                    }\n                    if ((entry == null ? void 0 : entry.value) && entry.value.kind === CachedRouteKind.FETCH) {\n                        // when stale and is revalidating we wait for fresh data\n                        // so the revalidated entry has the updated data\n                        if (workStore.isRevalidate && entry.isStale) {\n                            isForegroundRevalidate = true;\n                        } else {\n                            if (entry.isStale) {\n                                workStore.pendingRevalidates ??= {};\n                                if (!workStore.pendingRevalidates[cacheKey]) {\n                                    const pendingRevalidate = doOriginalFetch(true).then(async (response)=>({\n                                            body: await response.arrayBuffer(),\n                                            headers: response.headers,\n                                            status: response.status,\n                                            statusText: response.statusText\n                                        })).finally(()=>{\n                                        workStore.pendingRevalidates ??= {};\n                                        delete workStore.pendingRevalidates[cacheKey || ''];\n                                    });\n                                    // Attach the empty catch here so we don't get a \"unhandled\n                                    // promise rejection\" warning.\n                                    pendingRevalidate.catch(console.error);\n                                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate;\n                                }\n                            }\n                            cachedFetchData = entry.value.data;\n                        }\n                    }\n                }\n                if (cachedFetchData) {\n                    if (fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason,\n                            cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',\n                            cacheWarning,\n                            status: cachedFetchData.status || 200,\n                            method: (init == null ? void 0 : init.method) || 'GET'\n                        });\n                    }\n                    const response = new Response(Buffer.from(cachedFetchData.body, 'base64'), {\n                        headers: cachedFetchData.headers,\n                        status: cachedFetchData.status\n                    });\n                    Object.defineProperty(response, 'url', {\n                        value: cachedFetchData.url\n                    });\n                    return response;\n                }\n            }\n            if (workStore.isStaticGeneration && init && typeof init === 'object') {\n                const { cache } = init;\n                // Delete `cache` property as Cloudflare Workers will throw an error\n                if (isEdgeRuntime) delete init.cache;\n                if (cache === 'no-store') {\n                    // If enabled, we should bail out of static generation.\n                    if (workUnitStore) {\n                        switch(workUnitStore.type){\n                            case 'prerender':\n                            case 'prerender-client':\n                            case 'prerender-runtime':\n                                if (cacheSignal) {\n                                    cacheSignal.endRead();\n                                    cacheSignal = null;\n                                }\n                                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                            case 'prerender-ppr':\n                            case 'prerender-legacy':\n                            case 'request':\n                            case 'cache':\n                            case 'private-cache':\n                            case 'unstable-cache':\n                                break;\n                            default:\n                                workUnitStore;\n                        }\n                    }\n                    markCurrentScopeAsDynamic(workStore, workUnitStore, `no-store fetch ${input} ${workStore.route}`);\n                }\n                const hasNextConfig = 'next' in init;\n                const { next = {} } = init;\n                if (typeof next.revalidate === 'number' && revalidateStore && next.revalidate < revalidateStore.revalidate) {\n                    if (next.revalidate === 0) {\n                        // If enabled, we should bail out of static generation.\n                        if (workUnitStore) {\n                            switch(workUnitStore.type){\n                                case 'prerender':\n                                case 'prerender-client':\n                                case 'prerender-runtime':\n                                    return makeHangingPromise(workUnitStore.renderSignal, workStore.route, 'fetch()');\n                                case 'request':\n                                case 'cache':\n                                case 'private-cache':\n                                case 'unstable-cache':\n                                case 'prerender-legacy':\n                                case 'prerender-ppr':\n                                    break;\n                                default:\n                                    workUnitStore;\n                            }\n                        }\n                        markCurrentScopeAsDynamic(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                    }\n                    if (!workStore.forceStatic || next.revalidate !== 0) {\n                        revalidateStore.revalidate = next.revalidate;\n                    }\n                }\n                if (hasNextConfig) delete init.next;\n            }\n            // if we are revalidating the whole page via time or on-demand and\n            // the fetch cache entry is stale we should still de-dupe the\n            // origin hit if it's a cache-able entry\n            if (cacheKey && isForegroundRevalidate) {\n                const pendingRevalidateKey = cacheKey;\n                workStore.pendingRevalidates ??= {};\n                let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];\n                if (pendingRevalidate) {\n                    const revalidatedResult = await pendingRevalidate;\n                    return new Response(revalidatedResult.body, {\n                        headers: revalidatedResult.headers,\n                        status: revalidatedResult.status,\n                        statusText: revalidatedResult.statusText\n                    });\n                }\n                // We used to just resolve the Response and clone it however for\n                // static generation with cacheComponents we need the response to be able to\n                // be resolved in a microtask and cloning the response will never have\n                // a body that can resolve in a microtask in node (as observed through\n                // experimentation) So instead we await the body and then when it is\n                // available we construct manually cloned Response objects with the\n                // body as an ArrayBuffer. This will be resolvable in a microtask\n                // making it compatible with cacheComponents.\n                const pendingResponse = doOriginalFetch(true, cacheReasonOverride)// We're cloning the response using this utility because there\n                // exists a bug in the undici library around response cloning.\n                // See the following pull request for more details:\n                // https://github.com/vercel/next.js/pull/73274\n                .then(cloneResponse);\n                pendingRevalidate = pendingResponse.then(async (responses)=>{\n                    const response = responses[0];\n                    return {\n                        body: await response.arrayBuffer(),\n                        headers: response.headers,\n                        status: response.status,\n                        statusText: response.statusText\n                    };\n                }).finally(()=>{\n                    var _workStore_pendingRevalidates;\n                    // If the pending revalidate is not present in the store, then\n                    // we have nothing to delete.\n                    if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {\n                        return;\n                    }\n                    delete workStore.pendingRevalidates[pendingRevalidateKey];\n                });\n                // Attach the empty catch here so we don't get a \"unhandled promise\n                // rejection\" warning\n                pendingRevalidate.catch(()=>{});\n                workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;\n                return pendingResponse.then((responses)=>responses[1]);\n            } else {\n                return doOriginalFetch(false, cacheReasonOverride);\n            }\n        });\n        if (cacheSignal) {\n            try {\n                return await result;\n            } finally{\n                if (cacheSignal) {\n                    cacheSignal.endRead();\n                }\n            }\n        }\n        return result;\n    };\n    // Attach the necessary properties to the patched fetch function.\n    // We don't use this to determine if the fetch function has been patched,\n    // but for external consumers to determine if the fetch function has been\n    // patched.\n    patched.__nextPatched = true;\n    patched.__nextGetStaticStore = ()=>workAsyncStorage;\n    patched._nextOriginalFetch = originFetch;\n    globalThis[NEXT_PATCH_SYMBOL] = true;\n    // Assign the function name also as a name property, so that it's preserved\n    // even when mangling is enabled.\n    Object.defineProperty(patched, 'name', {\n        value: 'fetch',\n        writable: false\n    });\n    return patched;\n}\n// we patch fetch to collect cache information used for\n// determining if a page is static or not\nexport function patchFetch(options) {\n    // If we've already patched fetch, we should not patch it again.\n    if (isFetchPatched()) return;\n    // Grab the original fetch function. We'll attach this so we can use it in\n    // the patched fetch function.\n    const original = createDedupeFetch(globalThis.fetch);\n    // Set the global fetch to the patched fetch.\n    globalThis.fetch = createPatchedFetcher(original, options);\n}\n\n//# sourceMappingURL=patch-fetch.js.map","// ISC License\n// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1\nvar _globalThis;\nconst { env, stdout } = ((_globalThis = globalThis) == null ? void 0 : _globalThis.process) ?? {};\nconst enabled = env && !env.NO_COLOR && (env.FORCE_COLOR || (stdout == null ? void 0 : stdout.isTTY) && !env.CI && env.TERM !== 'dumb');\nconst replaceClose = (str, close, replace, index)=>{\n    const start = str.substring(0, index) + replace;\n    const end = str.substring(index + close.length);\n    const nextIndex = end.indexOf(close);\n    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;\n};\nconst formatter = (open, close, replace = open)=>{\n    if (!enabled) return String;\n    return (input)=>{\n        const string = '' + input;\n        const index = string.indexOf(close, open.length);\n        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;\n    };\n};\nexport const reset = enabled ? (s)=>`\\x1b[0m${s}\\x1b[0m` : String;\nexport const bold = formatter('\\x1b[1m', '\\x1b[22m', '\\x1b[22m\\x1b[1m');\nexport const dim = formatter('\\x1b[2m', '\\x1b[22m', '\\x1b[22m\\x1b[2m');\nexport const italic = formatter('\\x1b[3m', '\\x1b[23m');\nexport const underline = formatter('\\x1b[4m', '\\x1b[24m');\nexport const inverse = formatter('\\x1b[7m', '\\x1b[27m');\nexport const hidden = formatter('\\x1b[8m', '\\x1b[28m');\nexport const strikethrough = formatter('\\x1b[9m', '\\x1b[29m');\nexport const black = formatter('\\x1b[30m', '\\x1b[39m');\nexport const red = formatter('\\x1b[31m', '\\x1b[39m');\nexport const green = formatter('\\x1b[32m', '\\x1b[39m');\nexport const yellow = formatter('\\x1b[33m', '\\x1b[39m');\nexport const blue = formatter('\\x1b[34m', '\\x1b[39m');\nexport const magenta = formatter('\\x1b[35m', '\\x1b[39m');\nexport const purple = formatter('\\x1b[38;2;173;127;168m', '\\x1b[39m');\nexport const cyan = formatter('\\x1b[36m', '\\x1b[39m');\nexport const white = formatter('\\x1b[37m', '\\x1b[39m');\nexport const gray = formatter('\\x1b[90m', '\\x1b[39m');\nexport const bgBlack = formatter('\\x1b[40m', '\\x1b[49m');\nexport const bgRed = formatter('\\x1b[41m', '\\x1b[49m');\nexport const bgGreen = formatter('\\x1b[42m', '\\x1b[49m');\nexport const bgYellow = formatter('\\x1b[43m', '\\x1b[49m');\nexport const bgBlue = formatter('\\x1b[44m', '\\x1b[49m');\nexport const bgMagenta = formatter('\\x1b[45m', '\\x1b[49m');\nexport const bgCyan = formatter('\\x1b[46m', '\\x1b[49m');\nexport const bgWhite = formatter('\\x1b[47m', '\\x1b[49m');\n\n//# sourceMappingURL=picocolors.js.map","import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors';\nimport { LRUCache } from '../../server/lib/lru-cache';\nexport const prefixes = {\n    wait: white(bold('')),\n    error: red(bold('')),\n    warn: yellow(bold('')),\n    ready: '',\n    info: white(bold(' ')),\n    event: green(bold('')),\n    trace: magenta(bold(''))\n};\nconst LOGGING_METHOD = {\n    log: 'log',\n    warn: 'warn',\n    error: 'error'\n};\nfunction prefixedLog(prefixType, ...message) {\n    if ((message[0] === '' || message[0] === undefined) && message.length === 1) {\n        message.shift();\n    }\n    const consoleMethod = prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : 'log';\n    const prefix = prefixes[prefixType];\n    // If there's no message, don't print the prefix but a new line\n    if (message.length === 0) {\n        console[consoleMethod]('');\n    } else {\n        // Ensure if there's ANSI escape codes it's concatenated into one string.\n        // Chrome DevTool can only handle color if it's in one string.\n        if (message.length === 1 && typeof message[0] === 'string') {\n            console[consoleMethod](' ' + prefix + ' ' + message[0]);\n        } else {\n            console[consoleMethod](' ' + prefix, ...message);\n        }\n    }\n}\nexport function bootstrap(...message) {\n    // logging format: ' <prefix> <message>'\n    // e.g. '  Compiled successfully'\n    // Add spaces to align with the indent of other logs\n    console.log('   ' + message.join(' '));\n}\nexport function wait(...message) {\n    prefixedLog('wait', ...message);\n}\nexport function error(...message) {\n    prefixedLog('error', ...message);\n}\nexport function warn(...message) {\n    prefixedLog('warn', ...message);\n}\nexport function ready(...message) {\n    prefixedLog('ready', ...message);\n}\nexport function info(...message) {\n    prefixedLog('info', ...message);\n}\nexport function event(...message) {\n    prefixedLog('event', ...message);\n}\nexport function trace(...message) {\n    prefixedLog('trace', ...message);\n}\nconst warnOnceCache = new LRUCache(10000, (value)=>value.length);\nexport function warnOnce(...message) {\n    const key = message.join(' ');\n    if (!warnOnceCache.has(key)) {\n        warnOnceCache.set(key, key);\n        warn(...message);\n    }\n}\n\n//# sourceMappingURL=log.js.map","(()=>{\"use strict\";var e={328:e=>{function hash(e){var r=5381,_=e.length;while(_){r=r*33^e.charCodeAt(--_)}return r>>>0}e.exports=hash}};var r={};function __nccwpck_require__(_){var a=r[_];if(a!==undefined){return a.exports}var t=r[_]={exports:{}};var i=true;try{e[_](t,t.exports,__nccwpck_require__);i=false}finally{if(i)delete r[_]}return t.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(328);module.exports=_})();","const invalidServerComponentReactHooks = [\n  'useDeferredValue',\n  'useEffect',\n  'useImperativeHandle',\n  'useInsertionEffect',\n  'useLayoutEffect',\n  'useReducer',\n  'useRef',\n  'useState',\n  'useSyncExternalStore',\n  'useTransition',\n  'experimental_useOptimistic',\n  'useOptimistic',\n]\n\nfunction setMessage(error: Error, message: string): void {\n  error.message = message\n  if (error.stack) {\n    const lines = error.stack.split('\\n')\n    lines[0] = message\n    error.stack = lines.join('\\n')\n  }\n}\n\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */\nexport function getStackWithoutErrorMessage(error: Error): string {\n  const stack = error.stack\n  if (!stack) return ''\n  return stack.replace(/^[^\\n]*\\n/, '')\n}\n\nexport function formatServerError(error: Error): void {\n  if (typeof error?.message !== 'string') return\n\n  if (\n    error.message.includes(\n      'Class extends value undefined is not a constructor or null'\n    )\n  ) {\n    const addedMessage =\n      'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component'\n\n    // If this error instance already has the message, don't add it again\n    if (error.message.includes(addedMessage)) return\n\n    setMessage(\n      error,\n      `${error.message}\n\n${addedMessage}`\n    )\n    return\n  }\n\n  if (error.message.includes('createContext is not a function')) {\n    setMessage(\n      error,\n      'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component'\n    )\n    return\n  }\n\n  for (const clientHook of invalidServerComponentReactHooks) {\n    const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`)\n    if (regex.test(error.message)) {\n      setMessage(\n        error,\n        `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`\n      )\n      return\n    }\n  }\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import { RedirectStatusCode } from './redirect-status-code';\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\nexport var RedirectType = /*#__PURE__*/ function(RedirectType) {\n    RedirectType[\"push\"] = \"push\";\n    RedirectType[\"replace\"] = \"replace\";\n    return RedirectType;\n}({});\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */ export function isRedirectError(error) {\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\n        return false;\n    }\n    const digest = error.digest.split(';');\n    const [errorCode, type] = digest;\n    const destination = digest.slice(2, -2).join(';');\n    const status = digest.at(-2);\n    const statusCode = Number(status);\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in RedirectStatusCode;\n}\n\n//# sourceMappingURL=redirect-error.js.map","const ERROR_CODE_DELIMITER = '@';\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */ export const createDigestWithErrorCode = (thrownValue, originalDigest)=>{\n    if (typeof thrownValue === 'object' && thrownValue !== null && '__NEXT_ERROR_CODE' in thrownValue) {\n        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;\n    }\n    return originalDigest;\n};\nexport const extractNextErrorCode = (error)=>{\n    if (typeof error === 'object' && error !== null && '__NEXT_ERROR_CODE' in error && typeof error.__NEXT_ERROR_CODE === 'string') {\n        return error.__NEXT_ERROR_CODE;\n    }\n    if (typeof error === 'object' && error !== null && 'digest' in error && typeof error.digest === 'string') {\n        const segments = error.digest.split(ERROR_CODE_DELIMITER);\n        const errorCode = segments.find((segment)=>segment.startsWith('E'));\n        return errorCode;\n    }\n    return undefined;\n};\n\n//# sourceMappingURL=error-telemetry-utils.js.map","import { isHTTPAccessFallbackError } from './http-access-fallback/http-access-fallback';\nimport { isRedirectError } from './redirect-error';\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */ export function isNextRouterError(error) {\n    return isRedirectError(error) || isHTTPAccessFallbackError(error);\n}\n\n//# sourceMappingURL=is-next-router-error.js.map","import stringHash from 'next/dist/compiled/string-hash';\nimport { formatServerError } from '../../lib/format-server-error';\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer';\nimport { isAbortError } from '../pipe-readable';\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { isDynamicServerError } from '../../client/components/hooks-server-context';\nimport { isNextRouterError } from '../../client/components/is-next-router-error';\nimport { isPrerenderInterruptedError } from './dynamic-rendering';\nimport { getProperError } from '../../lib/is-error';\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils';\nimport { isReactLargeShellError } from './react-large-shell-error';\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */ export function getDigestForWellKnownError(error) {\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(error)) return error.digest;\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(error)) return error.digest;\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(error)) return error.digest;\n    // If this is a prerender interrupted error, we don't need to log the error.\n    if (isPrerenderInterruptedError(error)) return error.digest;\n    return undefined;\n}\nexport function createFlightReactServerErrorHandler(shouldFormatError, onReactServerRenderError) {\n    return (thrownValue)=>{\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + err.stack || '').toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Record exception in an active span, if available.\n        const span = getTracer().getActiveScopeSpan();\n        if (span) {\n            span.recordException(err);\n            span.setAttribute('error.type', err.name);\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message\n            });\n        }\n        onReactServerRenderError(err);\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLReactServerErrorHandler(shouldFormatError, isNextExport, reactServerErrors, silenceLogger, onReactServerRenderError) {\n    return (thrownValue)=>{\n        var _err_message;\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + (err.stack || '')).toString();\n        }\n        // @TODO by putting this here and not at the top it is possible that\n        // we don't error the build in places we actually expect to\n        if (!reactServerErrors.has(err.digest)) {\n            reactServerErrors.set(err.digest, err);\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger) {\n                onReactServerRenderError == null ? void 0 : onReactServerRenderError(err);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLErrorHandler(shouldFormatError, isNextExport, reactServerErrors, allCapturedErrors, silenceLogger, onHTMLRenderSSRError) {\n    return (thrownValue, errorInfo)=>{\n        var _err_message;\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        let isSSRError = true;\n        allCapturedErrors.push(thrownValue);\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (err.digest) {\n            if (reactServerErrors.has(err.digest)) {\n                // This error is likely an obfuscated error from react-server.\n                // We recover the original error here.\n                thrownValue = reactServerErrors.get(err.digest);\n                isSSRError = false;\n            } else {\n            // The error is not from react-server but has a digest\n            // from other means so we don't need to produce a new one\n            }\n        } else {\n            err.digest = stringHash(err.message + ((errorInfo == null ? void 0 : errorInfo.componentStack) || err.stack || '')).toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger && // HTML errors contain RSC errors as well, filter them out before reporting\n            isSSRError) {\n                onHTMLRenderSSRError(err, errorInfo);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function isUserLandError(err) {\n    return !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err);\n}\n\n//# sourceMappingURL=create-error-handler.js.map","export function getObjectClassLabel(value) {\n    return Object.prototype.toString.call(value);\n}\nexport function isPlainObject(value) {\n    if (getObjectClassLabel(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');\n}\n\n//# sourceMappingURL=is-plain-object.js.map","// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(error) {\n    return typeof error === 'object' && error !== null && 'message' in error && typeof error.message === 'string' && error.message.startsWith('This rendered a large document (>');\n}\n\n//# sourceMappingURL=react-large-shell-error.js.map","import { isPlainObject } from '../shared/lib/is-plain-object';\n/**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */ export default function isError(err) {\n    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;\n}\nfunction safeStringify(obj) {\n    const seen = new WeakSet();\n    return JSON.stringify(obj, (_key, value)=>{\n        // If value is an object and already seen, replace with \"[Circular]\"\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return '[Circular]';\n            }\n            seen.add(value);\n        }\n        return value;\n    });\n}\nexport function getProperError(err) {\n    if (isError(err)) {\n        return err;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        // provide better error for case where `throw undefined`\n        // is called in development\n        if (typeof err === 'undefined') {\n            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), \"__NEXT_ERROR_CODE\", {\n                value: \"E98\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (err === null) {\n            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), \"__NEXT_ERROR_CODE\", {\n                value: \"E336\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    return Object.defineProperty(new Error(isPlainObject(err) ? safeStringify(err) : err + ''), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=is-error.js.map","import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nimport { throwToInterruptStaticGeneration, postponeWithTracking, trackSynchronousRequestDataAccessInDev, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { describeStringPropertyAccess, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external';\nexport function createParamsFromClient(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E736\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E770\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport const createServerParamsForMetadata = createServerParamsForServerSegment;\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForRoute should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E738\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForServerSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E743\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createPrerenderParamsForClientSegment(underlyingParams) {\n    const workStore = workAsyncStorage.getStore();\n    if (!workStore) {\n        throw Object.defineProperty(new InvariantError('Missing workStore in createPrerenderParamsForClientSegment'), \"__NEXT_ERROR_CODE\", {\n            value: \"E773\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n                const fallbackParams = workUnitStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(let key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`params`');\n                        }\n                    }\n                }\n                break;\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createPrerenderParamsForClientSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E734\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'prerender-runtime':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // We're prerendering in a mode that does not abort. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve(underlyingParams);\n}\nfunction createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {\n    switch(prerenderStore.type){\n        case 'prerender':\n        case 'prerender-client':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingParams(underlyingParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-ppr':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-legacy':\n            break;\n        default:\n            prerenderStore;\n    }\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedParams(underlyingParams);\n    } else {\n        return makeUntrackedExoticParams(underlyingParams);\n    }\n}\nfunction createRuntimePrerenderParams(underlyingParams, workUnitStore) {\n    return delayUntilRuntimeStage(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedParams(underlyingParams) : makeUntrackedExoticParams(underlyingParams));\n}\nfunction createRenderParamsInProd(underlyingParams) {\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedParams(underlyingParams);\n    }\n    return makeUntrackedExoticParams(underlyingParams);\n}\nfunction createRenderParamsInDev(underlyingParams, devFallbackParams, workStore) {\n    let hasFallbackParams = false;\n    if (devFallbackParams) {\n        for(let key in underlyingParams){\n            if (devFallbackParams.has(key)) {\n                hasFallbackParams = true;\n                break;\n            }\n        }\n    }\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);\n    }\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);\n}\nconst CachedParams = new WeakMap();\nconst fallbackParamsProxyHandler = {\n    get: function get(target, prop, receiver) {\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n            const originalMethod = ReflectAdapter.get(target, prop, receiver);\n            return ({\n                [prop]: (...args)=>{\n                    const store = dynamicAccessAsyncStorage.getStore();\n                    if (store) {\n                        store.abortController.abort(Object.defineProperty(new Error(`Accessed fallback \\`params\\` during prerendering.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E691\",\n                            enumerable: false,\n                            configurable: true\n                        }));\n                    }\n                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);\n                }\n            })[prop];\n        }\n        return ReflectAdapter.get(target, prop, receiver);\n    }\n};\nfunction makeHangingParams(underlyingParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = new Proxy(makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`params`'), fallbackParamsProxyHandler);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const augmentedUnderlying = {\n        ...underlyingParams\n    };\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(augmentedUnderlying);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            if (fallbackParams.has(prop)) {\n                Object.defineProperty(augmentedUnderlying, prop, {\n                    get () {\n                        const expression = describeStringPropertyAccess('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when cacheComponents is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                    },\n                    enumerable: true\n                });\n                Object.defineProperty(promise, prop, {\n                    get () {\n                        const expression = describeStringPropertyAccess('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when cacheComponents is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                    },\n                    set (newValue) {\n                        Object.defineProperty(promise, prop, {\n                            value: newValue,\n                            writable: true,\n                            enumerable: true\n                        });\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            } else {\n                ;\n                promise[prop] = underlyingParams[prop];\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            ;\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = hasFallbackParams ? makeDevtoolsIOAwarePromise(underlyingParams) : Promise.resolve(underlyingParams);\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = describeStringPropertyAccess('params', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            syncIODev(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = hasFallbackParams ? makeDevtoolsIOAwarePromise(underlyingParams) : Promise.resolve(underlyingParams);\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = describeStringPropertyAccess('params', prop);\n                    warnForSyncAccess(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    if (missingProperties && missingProperties.length > 0) {\n        warnForIncompleteEnumeration(route, expression, missingProperties);\n    } else {\n        warnForSyncAccess(route, expression);\n    }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createParamsAccessError);\nconst warnForIncompleteEnumeration = createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError);\nfunction createParamsAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E307\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E482\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction describeListOfPropertyNames(properties) {\n    switch(properties.length){\n        case 0:\n            throw Object.defineProperty(new InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E531\",\n                enumerable: false,\n                configurable: true\n            });\n        case 1:\n            return `\\`${properties[0]}\\``;\n        case 2:\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n        default:\n            {\n                let description = '';\n                for(let i = 0; i < properties.length - 1; i++){\n                    description += `\\`${properties[i]}\\`, `;\n                }\n                description += `, and \\`${properties[properties.length - 1]}\\``;\n                return description;\n            }\n    }\n}\n\n//# sourceMappingURL=params.js.map","import * as React from 'react';\nconst errorRef = {\n    current: null\n};\n// React.cache is currently only available in canary/experimental React channels.\nconst cache = typeof React.cache === 'function' ? React.cache : (fn)=>fn;\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS ? console.error : console.warn;\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n(key)=>{\n    try {\n        logErrorOrWarn(errorRef.current);\n    } finally{\n        errorRef.current = null;\n    }\n});\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */ export function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\n    return function logDedupedError(...args) {\n        const message = getMessage(...args);\n        if (process.env.NODE_ENV !== 'production') {\n            var _stack;\n            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\n            if (callStackFrames === undefined || callStackFrames.length < 4) {\n                logErrorOrWarn(message);\n            } else {\n                // Error:\n                //   logDedupedError\n                //   asyncApiBeingAccessedSynchronously\n                //   <userland callsite>\n                // TODO: This breaks if sourcemaps with ignore lists are enabled.\n                const key = callStackFrames[4];\n                errorRef.current = message;\n                flushCurrentErrorIfNew(key);\n            }\n        } else {\n            logErrorOrWarn(message);\n        }\n    };\n}\n\n//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map","// Share the instance module in the next-shared layer\nimport { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with {\n    'turbopack-transition': 'next-shared'\n};\nexport { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage };\n\n//# sourceMappingURL=dynamic-access-async-storage.external.js.map","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external';\nexport function throwWithStaticGenerationBailoutError(route, expression) {\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E576\",\n        enumerable: false,\n        configurable: true\n    });\n}\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E543\",\n        enumerable: false,\n        configurable: true\n    });\n}\nexport function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {\n    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E779\",\n        enumerable: false,\n        configurable: true\n    });\n    Error.captureStackTrace(error, constructorOpt);\n    workStore.invalidDynamicUsageError ??= error;\n    throw error;\n}\nexport function isRequestAPICallableInsideAfter() {\n    const afterTaskStore = afterTaskAsyncStorage.getStore();\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\n}\n\n//# sourceMappingURL=utils.js.map","function resolveArray(value) {\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        value\n    ];\n}\nfunction resolveAsArrayOrUndefined(value) {\n    if (typeof value === 'undefined' || value === null) {\n        return undefined;\n    }\n    return resolveArray(value);\n}\nfunction getOrigin(url) {\n    let origin = undefined;\n    if (typeof url === 'string') {\n        try {\n            url = new URL(url);\n            origin = url.origin;\n        } catch  {}\n    }\n    return origin;\n}\nexport { resolveAsArrayOrUndefined, resolveArray, getOrigin };\n\n//# sourceMappingURL=utils.js.map"],"names":["invalidServerComponentReactHooks","setMessage","error","message","stack","lines","split","join","getStackWithoutErrorMessage","replace","formatServerError","includes","addedMessage","clientHook","regex","RegExp","test","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","digest","prefix","httpStatus","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","status","actionAsyncStorageInstance","actionAsyncStorage","isDefinitelyAValidIdentifier","describeStringPropertyAccess","target","prop","JSON","stringify","describeHasCheckingStringProperty","stringifiedProp","wellKnownProperties"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}