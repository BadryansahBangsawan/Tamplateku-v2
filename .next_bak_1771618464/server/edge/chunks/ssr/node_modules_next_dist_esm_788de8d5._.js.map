{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/client/components/http-access-fallback/error-boundary.tsx","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/disable-smooth-scroll.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/layout-router.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/bfcache.js","turbopack:///[project]/node_modules/next/dist/src/client/components/render-from-template-context.tsx","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/search-params.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/params.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/dynamic-access-async-storage.external.js","turbopack:///[project]/node_modules/next/dist/src/client/components/client-page.tsx","turbopack:///[project]/node_modules/next/dist/src/client/components/client-segment.tsx","turbopack:///[project]/node_modules/next/dist/src/lib/metadata/generate/icon-mark.tsx","turbopack:///[project]/node_modules/next/dist/src/client/components/metadata/async-metadata.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  children: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","import { warnOnce } from '../../utils/warn-once';\n/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ export function disableSmoothScrollDuringRouteTransition(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';\n    // Since this is a breaking change, this is temporarily flagged\n    // and will be false by default.\n    // In the next major (v16), this will be automatically enabled\n    if (process.env.__NEXT_OPTIMIZE_ROUTER_SCROLL) {\n        if (!hasDataAttribute) {\n            // No smooth scrolling configured, run directly without style manipulation\n            fn();\n            return;\n        }\n    } else {\n        // Old behavior: always manipulate styles, but warn about upcoming change\n        // Warn if smooth scrolling is detected but no data attribute is present\n        if (process.env.NODE_ENV === 'development' && !hasDataAttribute && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {\n            warnOnce('Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, ' + 'Next.js will no longer automatically disable smooth scrolling during route transitions. ' + 'To prepare for this change, add `data-scroll-behavior=\"smooth\"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');\n        }\n    }\n    // Proceed with temporarily disabling smooth scrolling\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n//# sourceMappingURL=disable-smooth-scroll.js.map","'use client';\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { ACTION_SERVER_PATCH } from './router-reducer/router-reducer-types';\nimport React, { useContext, use, startTransition, Suspense, useDeferredValue } from 'react';\nimport ReactDOM from 'react-dom';\nimport { LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from '../../shared/lib/app-router-context.shared-runtime';\nimport { fetchServerResponse } from './router-reducer/fetch-server-response';\nimport { unresolvedThenable } from './unresolved-thenable';\nimport { ErrorBoundary } from './error-boundary';\nimport { matchSegment } from './match-segments';\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll';\nimport { RedirectBoundary } from './redirect-boundary';\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary';\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key';\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree';\nimport { dispatchAppRouterAction } from './use-action-queue';\nimport { useRouterBFCache } from './bfcache';\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE ? require('react').unstable_Activity : null;\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if (matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                'refetch'\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (typeof window === 'undefined') return null;\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n    // We need to lazily reference it.\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\n    return internal_reactDOMfindDOMNode(instance);\n}\nconst rectProperties = [\n    'bottom',\n    'height',\n    'left',\n    'right',\n    'top',\n    'width',\n    'x',\n    'y'\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        'sticky',\n        'fixed'\n    ].includes(getComputedStyle(element).position)) {\n        if (process.env.NODE_ENV === 'development') {\n            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === 'top') {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends React.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args), this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    if (process.env.NODE_ENV !== 'production') {\n                        var _domNode_parentElement;\n                        if (((_domNode_parentElement = domNode.parentElement) == null ? void 0 : _domNode_parentElement.localName) === 'head') {\n                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n                        // This is always a bug in Next.js and caused by React hoisting metadata.\n                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n                        }\n                    }\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                disableSmoothScrollDuringRouteTransition(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        ;\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        // Scroll into view doesn't scroll horizontally by default when not needed\n                        ;\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = useContext(GlobalLayoutRouterContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E473\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return /*#__PURE__*/ _jsx(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { tree, segmentPath, cacheNode, url } = param;\n    const context = useContext(GlobalLayoutRouterContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E473\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { tree: fullTree } = context;\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    const rsc = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? use(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        let lazyData = cacheNode.lazyData;\n        if (lazyData === null) {\n            /**\n       * Router state with refetch marker added\n       */ // TODO-APP: remove ''\n            const refetchTree = walkAddRefetch([\n                '',\n                ...segmentPath\n            ], fullTree);\n            const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree);\n            const navigatedAt = Date.now();\n            cacheNode.lazyData = lazyData = fetchServerResponse(new URL(url, location.origin), {\n                flightRouterState: refetchTree,\n                nextUrl: includeNextUrl ? context.nextUrl : null\n            }).then((serverResponse)=>{\n                startTransition(()=>{\n                    dispatchAppRouterAction({\n                        type: ACTION_SERVER_PATCH,\n                        previousTree: fullTree,\n                        serverResponse,\n                        navigatedAt\n                    });\n                });\n                return serverResponse;\n            });\n            // Suspend while waiting for lazyData to resolve\n            use(lazyData);\n        }\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n        use(unresolvedThenable);\n    }\n    // If we get to this point, then we know we have something we can render.\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\n    /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {\n        value: {\n            parentTree: tree,\n            parentCacheNode: cacheNode,\n            parentSegmentPath: segmentPath,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { loading, children } = param;\n    // If loading is a promise, unwrap it. This happens in cases where we haven't\n    // yet received the loading data from the server — which includes whether or\n    // not this layout has a loading component at all.\n    //\n    // It's OK to suspend here instead of inside the fallback because this\n    // promise will resolve simultaneously with the data for the segment itself.\n    // So it will never suspend for longer than it would have if we didn't use\n    // a Suspense fallback at all.\n    let loadingModuleData;\n    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {\n        const promiseForLoading = loading;\n        loadingModuleData = use(promiseForLoading);\n    } else {\n        loadingModuleData = loading;\n    }\n    if (loadingModuleData) {\n        const loadingRsc = loadingModuleData[0];\n        const loadingStyles = loadingModuleData[1];\n        const loadingScripts = loadingModuleData[2];\n        return /*#__PURE__*/ _jsx(Suspense, {\n            fallback: /*#__PURE__*/ _jsxs(_Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loadingRsc\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ _jsx(_Fragment, {\n        children: children\n    });\n}\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */ export default function OuterLayoutRouter(param) {\n    let { parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries } = param;\n    const context = useContext(LayoutRouterContext);\n    if (!context) {\n        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), \"__NEXT_ERROR_CODE\", {\n            value: \"E56\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { parentTree, parentCacheNode, parentSegmentPath, url } = context;\n    // Get the CacheNode for this segment by reading it from the parent segment's\n    // child map.\n    const parentParallelRoutes = parentCacheNode.parallelRoutes;\n    let segmentMap = parentParallelRoutes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!segmentMap) {\n        segmentMap = new Map();\n        parentParallelRoutes.set(parallelRouterKey, segmentMap);\n    }\n    const parentTreeSegment = parentTree[0];\n    const segmentPath = parentSegmentPath === null ? // path. This has led to a bunch of special cases scattered throughout\n    // the code. We should clean this up.\n    [\n        parallelRouterKey\n    ] : parentSegmentPath.concat([\n        parentTreeSegment,\n        parallelRouterKey\n    ]);\n    // The \"state\" key of a segment is the one passed to React — it represents the\n    // identity of the UI tree. Whenever the state key changes, the tree is\n    // recreated and the state is reset. In the App Router model, search params do\n    // not cause state to be lost, so two segments with the same segment path but\n    // different search params should have the same state key.\n    //\n    // The \"cache\" key of a segment, however, *does* include the search params, if\n    // it's possible that the segment accessed the search params on the server.\n    // (This only applies to page segments; layout segments cannot access search\n    // params on the server.)\n    const activeTree = parentTree[1][parallelRouterKey];\n    const activeSegment = activeTree[0];\n    const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n    ;\n    // At each level of the route tree, not only do we render the currently\n    // active segment — we also render the last N segments that were active at\n    // this level inside a hidden <Activity> boundary, to preserve their state\n    // if or when the user navigates to them again.\n    //\n    // bfcacheEntry is a linked list of FlightRouterStates.\n    let bfcacheEntry = useRouterBFCache(activeTree, activeStateKey);\n    let children = [];\n    do {\n        const tree = bfcacheEntry.tree;\n        const stateKey = bfcacheEntry.stateKey;\n        const segment = tree[0];\n        const cacheKey = createRouterCacheKey(segment);\n        // Read segment path from the parallel router cache node.\n        let cacheNode = segmentMap.get(cacheKey);\n        if (cacheNode === undefined) {\n            // When data is not available during rendering client-side we need to fetch\n            // it from the server.\n            const newLazyCacheNode = {\n                lazyData: null,\n                rsc: null,\n                prefetchRsc: null,\n                head: null,\n                prefetchHead: null,\n                parallelRoutes: new Map(),\n                loading: null,\n                navigatedAt: -1\n            };\n            // Flight data fetch kicked off during render and put into the cache.\n            cacheNode = newLazyCacheNode;\n            segmentMap.set(cacheKey, newLazyCacheNode);\n        }\n        /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */ let segmentBoundaryTriggerNode = null;\n        let segmentViewStateNode = null;\n        if (process.env.NODE_ENV !== 'production' && process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER) {\n            const { SegmentBoundaryTriggerNode, SegmentViewStateNode } = require('../../next-devtools/userspace/app/segment-explorer-node');\n            const pagePrefix = normalizeAppPath(url);\n            segmentViewStateNode = /*#__PURE__*/ _jsx(SegmentViewStateNode, {\n                page: pagePrefix\n            }, pagePrefix);\n            segmentBoundaryTriggerNode = /*#__PURE__*/ _jsx(_Fragment, {\n                children: /*#__PURE__*/ _jsx(SegmentBoundaryTriggerNode, {})\n            });\n        }\n        // TODO: The loading module data for a segment is stored on the parent, then\n        // applied to each of that parent segment's parallel route slots. In the\n        // simple case where there's only one parallel route (the `children` slot),\n        // this is no different from if the loading module data where stored on the\n        // child directly. But I'm not sure this actually makes sense when there are\n        // multiple parallel routes. It's not a huge issue because you always have\n        // the option to define a narrower loading boundary for a particular slot. But\n        // this sort of smells like an implementation accident to me.\n        const loadingModuleData = parentCacheNode.loading;\n        let child = /*#__PURE__*/ _jsxs(TemplateContext.Provider, {\n            value: /*#__PURE__*/ _jsxs(ScrollAndFocusHandler, {\n                segmentPath: segmentPath,\n                children: [\n                    /*#__PURE__*/ _jsx(ErrorBoundary, {\n                        errorComponent: error,\n                        errorStyles: errorStyles,\n                        errorScripts: errorScripts,\n                        children: /*#__PURE__*/ _jsx(LoadingBoundary, {\n                            loading: loadingModuleData,\n                            children: /*#__PURE__*/ _jsx(HTTPAccessFallbackBoundary, {\n                                notFound: notFound,\n                                forbidden: forbidden,\n                                unauthorized: unauthorized,\n                                children: /*#__PURE__*/ _jsxs(RedirectBoundary, {\n                                    children: [\n                                        /*#__PURE__*/ _jsx(InnerLayoutRouter, {\n                                            url: url,\n                                            tree: tree,\n                                            cacheNode: cacheNode,\n                                            segmentPath: segmentPath\n                                        }),\n                                        segmentBoundaryTriggerNode\n                                    ]\n                                })\n                            })\n                        })\n                    }),\n                    segmentViewStateNode\n                ]\n            }),\n            children: [\n                templateStyles,\n                templateScripts,\n                template\n            ]\n        }, stateKey);\n        if (process.env.NODE_ENV !== 'production') {\n            const { SegmentStateProvider } = require('../../next-devtools/userspace/app/segment-explorer-node');\n            child = /*#__PURE__*/ _jsxs(SegmentStateProvider, {\n                children: [\n                    child,\n                    segmentViewBoundaries\n                ]\n            }, stateKey);\n        }\n        if (process.env.__NEXT_ROUTER_BF_CACHE) {\n            child = /*#__PURE__*/ _jsx(Activity, {\n                mode: stateKey === activeStateKey ? 'visible' : 'hidden',\n                children: child\n            }, stateKey);\n        }\n        children.push(child);\n        bfcacheEntry = bfcacheEntry.next;\n    }while (bfcacheEntry !== null);\n    return children;\n}\n\n//# sourceMappingURL=layout-router.js.map","import { useState } from 'react';\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1;\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook —\n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */ export function useRouterBFCache(activeTree, activeStateKey) {\n    // The currently active entry. The entries form a linked list, sorted in\n    // order of most recently active. This allows us to reuse parts of the list\n    // without cloning, unless there's a reordering or removal.\n    // TODO: Once we start tracking back/forward history at each route level,\n    // we should use the history order instead. In other words, when traversing\n    // to an existing entry as a result of a popstate event, we should maintain\n    // the existing order instead of moving it to the front of the list. I think\n    // an initial implementation of this could be to pass an incrementing id\n    // to history.pushState/replaceState, then use that here for ordering.\n    const [prevActiveEntry, setPrevActiveEntry] = useState(()=>{\n        const initialEntry = {\n            tree: activeTree,\n            stateKey: activeStateKey,\n            next: null\n        };\n        return initialEntry;\n    });\n    if (prevActiveEntry.tree === activeTree) {\n        // Fast path. The active tree hasn't changed, so we can reuse the\n        // existing state.\n        return prevActiveEntry;\n    }\n    // The route tree changed. Note that this doesn't mean that the tree changed\n    // *at this level* — the change may be due to a child route. Either way, we\n    // need to either add or update the router tree in the bfcache.\n    //\n    // The rest of the code looks more complicated than it actually is because we\n    // can't mutate the state in place; we have to copy-on-write.\n    // Create a new entry for the active cache key. This is the head of the new\n    // linked list.\n    const newActiveEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null\n    };\n    // We need to append the old list onto the new list. If the head of the new\n    // list was already present in the cache, then we'll need to clone everything\n    // that came before it. Then we can reuse the rest.\n    let n = 1;\n    let oldEntry = prevActiveEntry;\n    let clonedEntry = newActiveEntry;\n    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){\n        if (oldEntry.stateKey === activeStateKey) {\n            // Fast path. This entry in the old list that corresponds to the key that\n            // is now active. We've already placed a clone of this entry at the front\n            // of the new list. We can reuse the rest of the old list without cloning.\n            // NOTE: We don't need to worry about eviction in this case because we\n            // haven't increased the size of the cache, and we assume the max size\n            // is constant across renders. If we were to change it to a dynamic limit,\n            // then the implementation would need to account for that.\n            clonedEntry.next = oldEntry.next;\n            break;\n        } else {\n            // Clone the entry and append it to the list.\n            n++;\n            const entry = {\n                tree: oldEntry.tree,\n                stateKey: oldEntry.stateKey,\n                next: null\n            };\n            clonedEntry.next = entry;\n            clonedEntry = entry;\n        }\n        oldEntry = oldEntry.next;\n    }\n    setPrevActiveEntry(newActiveEntry);\n    return newActiveEntry;\n}\n\n//# sourceMappingURL=bfcache.js.map","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nexport function describeStringPropertyAccess(target, prop) {\n    if (isDefinitelyAValidIdentifier.test(prop)) {\n        return \"`\" + target + \".\" + prop + \"`\";\n    }\n    return \"`\" + target + \"[\" + JSON.stringify(prop) + \"]`\";\n}\nexport function describeHasCheckingStringProperty(target, prop) {\n    const stringifiedProp = JSON.stringify(prop);\n    return \"`Reflect.has(\" + target + \", \" + stringifiedProp + \")`, `\" + stringifiedProp + \" in \" + target + \"`, or similar\";\n}\nexport const wellKnownProperties = new Set([\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n    'toLocaleString',\n    // Promise prototype\n    // fallthrough\n    'then',\n    'catch',\n    'finally',\n    // React Promise extension\n    // fallthrough\n    'status',\n    // React introspection\n    'displayName',\n    '_debugInfo',\n    // Common tested properties\n    // fallthrough\n    'toJSON',\n    '$$typeof',\n    '__esModule'\n]);\n\n//# sourceMappingURL=reflect-utils.js.map","import * as React from 'react';\nconst errorRef = {\n    current: null\n};\n// React.cache is currently only available in canary/experimental React channels.\nconst cache = typeof React.cache === 'function' ? React.cache : (fn)=>fn;\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS ? console.error : console.warn;\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n(key)=>{\n    try {\n        logErrorOrWarn(errorRef.current);\n    } finally{\n        errorRef.current = null;\n    }\n});\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */ export function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\n    return function logDedupedError(...args) {\n        const message = getMessage(...args);\n        if (process.env.NODE_ENV !== 'production') {\n            var _stack;\n            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\n            if (callStackFrames === undefined || callStackFrames.length < 4) {\n                logErrorOrWarn(message);\n            } else {\n                // Error:\n                //   logDedupedError\n                //   asyncApiBeingAccessedSynchronously\n                //   <userland callsite>\n                // TODO: This breaks if sourcemaps with ignore lists are enabled.\n                const key = callStackFrames[4];\n                errorRef.current = message;\n                flushCurrentErrorIfNew(key);\n            }\n        } else {\n            logErrorOrWarn(message);\n        }\n    };\n}\n\n//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external';\nexport function throwWithStaticGenerationBailoutError(route, expression) {\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E576\",\n        enumerable: false,\n        configurable: true\n    });\n}\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E543\",\n        enumerable: false,\n        configurable: true\n    });\n}\nexport function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {\n    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E779\",\n        enumerable: false,\n        configurable: true\n    });\n    Error.captureStackTrace(error, constructorOpt);\n    workStore.invalidDynamicUsageError ??= error;\n    throw error;\n}\nexport function isRequestAPICallableInsideAfter() {\n    const afterTaskStore = afterTaskAsyncStorage.getStore();\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\n}\n\n//# sourceMappingURL=utils.js.map","import { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nimport { throwToInterruptStaticGeneration, postponeWithTracking, trackDynamicDataInDynamicRender, annotateDynamicAccess, trackSynchronousRequestDataAccessInDev, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { describeStringPropertyAccess, describeHasCheckingStringProperty, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\nimport { throwWithStaticGenerationBailoutErrorWithDynamicError, throwForSearchParamsAccessInUseCache } from './utils';\nexport function createSearchParamsFromClient(underlyingSearchParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E769\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E739\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'request':\n                return createRenderSearchParams(underlyingSearchParams, workStore);\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\nexport function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerSearchParamsForServerPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E747\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);\n            case 'request':\n                return createRenderSearchParams(underlyingSearchParams, workStore);\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createPrerenderSearchParamsForClientPage(workStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n                // We're prerendering in a mode that aborts (cacheComponents) and should stall\n                // the promise to ensure the RSC side is considered dynamic\n                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`searchParams`');\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E768\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E746\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'request':\n                return Promise.resolve({});\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nfunction createStaticPrerenderSearchParams(workStore, prerenderStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    }\n    switch(prerenderStore.type){\n        case 'prerender':\n        case 'prerender-client':\n            // We are in a cacheComponents (PPR or otherwise) prerender\n            return makeHangingSearchParams(workStore, prerenderStore);\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n            // We are in a legacy static generation and need to interrupt the\n            // prerender when search params are accessed.\n            return makeErroringExoticSearchParams(workStore, prerenderStore);\n        default:\n            return prerenderStore;\n    }\n}\nfunction createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {\n    return delayUntilRuntimeStage(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedSearchParams(underlyingSearchParams) : makeUntrackedExoticSearchParams(underlyingSearchParams));\n}\nfunction createRenderSearchParams(underlyingSearchParams, workStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n                return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\n            }\n            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\n        } else {\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n                return makeUntrackedSearchParams(underlyingSearchParams);\n            }\n            return makeUntrackedExoticSearchParams(underlyingSearchParams);\n        }\n    }\n}\nconst CachedSearchParams = new WeakMap();\nconst CachedSearchParamsForUseCache = new WeakMap();\nfunction makeHangingSearchParams(workStore, prerenderStore) {\n    const cachedSearchParams = CachedSearchParams.get(prerenderStore);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const promise = makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`searchParams`');\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (Object.hasOwn(promise, prop)) {\n                // The promise has this property directly. we must return it.\n                // We know it isn't a dynamic access because it can only be something\n                // that was previously written to the promise and thus not an underlying searchParam value\n                return ReflectAdapter.get(target, prop, receiver);\n            }\n            switch(prop){\n                case 'then':\n                    {\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\n                        annotateDynamicAccess(expression, prerenderStore);\n                        return ReflectAdapter.get(target, prop, receiver);\n                    }\n                case 'status':\n                    {\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n                        annotateDynamicAccess(expression, prerenderStore);\n                        return ReflectAdapter.get(target, prop, receiver);\n                    }\n                default:\n                    {\n                        return ReflectAdapter.get(target, prop, receiver);\n                    }\n            }\n        }\n    });\n    CachedSearchParams.set(prerenderStore, proxiedPromise);\n    return proxiedPromise;\n}\nfunction makeErroringExoticSearchParams(workStore, prerenderStore) {\n    const cachedSearchParams = CachedSearchParams.get(workStore);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const underlyingSearchParams = {};\n    // For search params we don't construct a ReactPromise because we want to interrupt\n    // rendering on any property access that was not set from outside and so we only want\n    // to have properties like value and status if React sets them.\n    const promise = Promise.resolve(underlyingSearchParams);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (Object.hasOwn(promise, prop)) {\n                // The promise has this property directly. we must return it.\n                // We know it isn't a dynamic access because it can only be something\n                // that was previously written to the promise and thus not an underlying searchParam value\n                return ReflectAdapter.get(target, prop, receiver);\n            }\n            switch(prop){\n                case 'then':\n                    {\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\n                        if (workStore.dynamicShouldError) {\n                            throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\n                        } else if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                        return;\n                    }\n                case 'status':\n                    {\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n                        if (workStore.dynamicShouldError) {\n                            throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\n                        } else if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                        return;\n                    }\n                default:\n                    {\n                        if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n                            const expression = describeStringPropertyAccess('searchParams', prop);\n                            if (workStore.dynamicShouldError) {\n                                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\n                            } else if (prerenderStore.type === 'prerender-ppr') {\n                                // PPR Prerender (no cacheComponents)\n                                postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                            } else {\n                                // Legacy Prerender\n                                throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                            }\n                        }\n                        return ReflectAdapter.get(target, prop, receiver);\n                    }\n            }\n        },\n        has (target, prop) {\n            // We don't expect key checking to be used except for testing the existence of\n            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n            // you are testing whether the searchParams has a 'then' property.\n            if (typeof prop === 'string') {\n                const expression = describeHasCheckingStringProperty('searchParams', prop);\n                if (workStore.dynamicShouldError) {\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\n                } else if (prerenderStore.type === 'prerender-ppr') {\n                    // PPR Prerender (no cacheComponents)\n                    postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                } else {\n                    // Legacy Prerender\n                    throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                }\n                return false;\n            }\n            return ReflectAdapter.has(target, prop);\n        },\n        ownKeys () {\n            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n            if (workStore.dynamicShouldError) {\n                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no cacheComponents)\n                postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n                // Legacy Prerender\n                throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n            }\n        }\n    });\n    CachedSearchParams.set(workStore, proxiedPromise);\n    return proxiedPromise;\n}\n/**\n * This is a variation of `makeErroringExoticSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */ export function makeErroringSearchParamsForUseCache(workStore) {\n    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const promise = Promise.resolve({});\n    const proxiedPromise = new Proxy(promise, {\n        get: function get(target, prop, receiver) {\n            if (Object.hasOwn(promise, prop)) {\n                // The promise has this property directly. we must return it. We know it\n                // isn't a dynamic access because it can only be something that was\n                // previously written to the promise and thus not an underlying\n                // searchParam value\n                return ReflectAdapter.get(target, prop, receiver);\n            }\n            if (typeof prop === 'string' && (prop === 'then' || !wellKnownProperties.has(prop))) {\n                throwForSearchParamsAccessInUseCache(workStore, get);\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        has: function has(target, prop) {\n            // We don't expect key checking to be used except for testing the existence of\n            // searchParams so we make all has tests throw an error. this means that `promise.then`\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n            // you are testing whether the searchParams has a 'then' property.\n            if (typeof prop === 'string' && (prop === 'then' || !wellKnownProperties.has(prop))) {\n                throwForSearchParamsAccessInUseCache(workStore, has);\n            }\n            return ReflectAdapter.has(target, prop);\n        },\n        ownKeys: function ownKeys() {\n            throwForSearchParamsAccessInUseCache(workStore, ownKeys);\n        }\n    });\n    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);\n    return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    // We don't use makeResolvedReactPromise here because searchParams\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingSearchParams);\n    CachedSearchParams.set(underlyingSearchParams, promise);\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        if (!wellKnownProperties.has(prop)) {\n            Object.defineProperty(promise, prop, {\n                get () {\n                    const workUnitStore = workUnitAsyncStorage.getStore();\n                    if (workUnitStore) {\n                        trackDynamicDataInDynamicRender(workUnitStore);\n                    }\n                    return underlyingSearchParams[prop];\n                },\n                set (value) {\n                    Object.defineProperty(promise, prop, {\n                        value,\n                        writable: true,\n                        enumerable: true\n                    });\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedSearchParams(underlyingSearchParams) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const promise = Promise.resolve(underlyingSearchParams);\n    CachedSearchParams.set(underlyingSearchParams, promise);\n    return promise;\n}\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n    let promiseInitialized = false;\n    const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string' && promiseInitialized) {\n                if (store.dynamicShouldError) {\n                    const expression = describeStringPropertyAccess('searchParams', prop);\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\n                }\n                const workUnitStore = workUnitAsyncStorage.getStore();\n                if (workUnitStore) {\n                    trackDynamicDataInDynamicRender(workUnitStore);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (store.dynamicShouldError) {\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            if (store.dynamicShouldError) {\n                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n                throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\n            }\n            return Reflect.ownKeys(target);\n        }\n    });\n    // We don't use makeResolvedReactPromise here because searchParams\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams);\n    promise.then(()=>{\n        promiseInitialized = true;\n    });\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n            Object.defineProperty(promise, prop, {\n                get () {\n                    return proxiedUnderlying[prop];\n                },\n                set (newValue) {\n                    Object.defineProperty(promise, prop, {\n                        value: newValue,\n                        writable: true,\n                        enumerable: true\n                    });\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (prop === 'then' && store.dynamicShouldError) {\n                const expression = '`searchParams.then`';\n                throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\n            }\n            if (typeof prop === 'string') {\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = describeStringPropertyAccess('searchParams', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            const expression = '`Object.keys(searchParams)` or similar';\n            syncIODev(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n    return proxiedPromise;\n}\n// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but\n// just logging the sync access without actually defining the search params on\n// the promise.\nfunction makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams);\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = describeStringPropertyAccess('searchParams', prop);\n                    warnForSyncAccess(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\n                    warnForSyncAccess(store.route, expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            const expression = '`Object.keys(searchParams)` or similar';\n            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n    // In all cases we warn normally\n    if (missingProperties && missingProperties.length > 0) {\n        warnForIncompleteEnumeration(route, expression, missingProperties);\n    } else {\n        warnForSyncAccess(route, expression);\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createSearchAccessError);\nconst warnForIncompleteEnumeration = createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError);\nfunction createSearchAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E249\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E2\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction describeListOfPropertyNames(properties) {\n    switch(properties.length){\n        case 0:\n            throw Object.defineProperty(new InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E531\",\n                enumerable: false,\n                configurable: true\n            });\n        case 1:\n            return `\\`${properties[0]}\\``;\n        case 2:\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n        default:\n            {\n                let description = '';\n                for(let i = 0; i < properties.length - 1; i++){\n                    description += `\\`${properties[i]}\\`, `;\n                }\n                description += `, and \\`${properties[properties.length - 1]}\\``;\n                return description;\n            }\n    }\n}\n\n//# sourceMappingURL=search-params.js.map","import { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\nimport { throwToInterruptStaticGeneration, postponeWithTracking, trackSynchronousRequestDataAccessInDev, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { describeStringPropertyAccess, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external';\nexport function createParamsFromClient(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E736\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError('createParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E770\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport const createServerParamsForMetadata = createServerParamsForServerSegment;\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForRoute should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E738\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createServerParamsForServerSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E743\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-runtime':\n                return createRuntimePrerenderParams(underlyingParams, workUnitStore);\n            case 'request':\n                if (process.env.NODE_ENV === 'development') {\n                    // Semantically we only need the dev tracking when running in `next dev`\n                    // but since you would never use next dev with production NODE_ENV we use this\n                    // as a proxy so we can statically exclude this code from production builds.\n                    const devFallbackParams = workUnitStore.devFallbackParams;\n                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);\n                } else {\n                    return createRenderParamsInProd(underlyingParams);\n                }\n            default:\n                workUnitStore;\n        }\n    }\n    throwInvariantForMissingStore();\n}\nexport function createPrerenderParamsForClientSegment(underlyingParams) {\n    const workStore = workAsyncStorage.getStore();\n    if (!workStore) {\n        throw Object.defineProperty(new InvariantError('Missing workStore in createPrerenderParamsForClientSegment'), \"__NEXT_ERROR_CODE\", {\n            value: \"E773\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-client':\n                const fallbackParams = workUnitStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(let key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`params`');\n                        }\n                    }\n                }\n                break;\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                throw Object.defineProperty(new InvariantError('createPrerenderParamsForClientSegment should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E734\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'prerender-runtime':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // We're prerendering in a mode that does not abort. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve(underlyingParams);\n}\nfunction createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {\n    switch(prerenderStore.type){\n        case 'prerender':\n        case 'prerender-client':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            // This params object has one or more fallback params, so we need\n                            // to consider the awaiting of this params object \"dynamic\". Since\n                            // we are in cacheComponents mode we encode this as a promise that never\n                            // resolves.\n                            return makeHangingParams(underlyingParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-ppr':\n            {\n                const fallbackParams = prerenderStore.fallbackRouteParams;\n                if (fallbackParams) {\n                    for(const key in underlyingParams){\n                        if (fallbackParams.has(key)) {\n                            return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n                        }\n                    }\n                }\n                break;\n            }\n        case 'prerender-legacy':\n            break;\n        default:\n            prerenderStore;\n    }\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedParams(underlyingParams);\n    } else {\n        return makeUntrackedExoticParams(underlyingParams);\n    }\n}\nfunction createRuntimePrerenderParams(underlyingParams, workUnitStore) {\n    return delayUntilRuntimeStage(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedParams(underlyingParams) : makeUntrackedExoticParams(underlyingParams));\n}\nfunction createRenderParamsInProd(underlyingParams) {\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedParams(underlyingParams);\n    }\n    return makeUntrackedExoticParams(underlyingParams);\n}\nfunction createRenderParamsInDev(underlyingParams, devFallbackParams, workStore) {\n    let hasFallbackParams = false;\n    if (devFallbackParams) {\n        for(let key in underlyingParams){\n            if (devFallbackParams.has(key)) {\n                hasFallbackParams = true;\n                break;\n            }\n        }\n    }\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);\n    }\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);\n}\nconst CachedParams = new WeakMap();\nconst fallbackParamsProxyHandler = {\n    get: function get(target, prop, receiver) {\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n            const originalMethod = ReflectAdapter.get(target, prop, receiver);\n            return ({\n                [prop]: (...args)=>{\n                    const store = dynamicAccessAsyncStorage.getStore();\n                    if (store) {\n                        store.abortController.abort(Object.defineProperty(new Error(`Accessed fallback \\`params\\` during prerendering.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E691\",\n                            enumerable: false,\n                            configurable: true\n                        }));\n                    }\n                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);\n                }\n            })[prop];\n        }\n        return ReflectAdapter.get(target, prop, receiver);\n    }\n};\nfunction makeHangingParams(underlyingParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = new Proxy(makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`params`'), fallbackParamsProxyHandler);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const augmentedUnderlying = {\n        ...underlyingParams\n    };\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(augmentedUnderlying);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            if (fallbackParams.has(prop)) {\n                Object.defineProperty(augmentedUnderlying, prop, {\n                    get () {\n                        const expression = describeStringPropertyAccess('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when cacheComponents is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                    },\n                    enumerable: true\n                });\n                Object.defineProperty(promise, prop, {\n                    get () {\n                        const expression = describeStringPropertyAccess('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when cacheComponents is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no cacheComponents)\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\n                        }\n                    },\n                    set (newValue) {\n                        Object.defineProperty(promise, prop, {\n                            value: newValue,\n                            writable: true,\n                            enumerable: true\n                        });\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            } else {\n                ;\n                promise[prop] = underlyingParams[prop];\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            ;\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = hasFallbackParams ? makeDevtoolsIOAwarePromise(underlyingParams) : Promise.resolve(underlyingParams);\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = describeStringPropertyAccess('params', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            syncIODev(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = hasFallbackParams ? makeDevtoolsIOAwarePromise(underlyingParams) : Promise.resolve(underlyingParams);\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = describeStringPropertyAccess('params', prop);\n                    warnForSyncAccess(store.route, expression);\n                }\n            }\n            return ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    if (missingProperties && missingProperties.length > 0) {\n        warnForIncompleteEnumeration(route, expression, missingProperties);\n    } else {\n        warnForSyncAccess(route, expression);\n    }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createParamsAccessError);\nconst warnForIncompleteEnumeration = createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError);\nfunction createParamsAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E307\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E482\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction describeListOfPropertyNames(properties) {\n    switch(properties.length){\n        case 0:\n            throw Object.defineProperty(new InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E531\",\n                enumerable: false,\n                configurable: true\n            });\n        case 1:\n            return `\\`${properties[0]}\\``;\n        case 2:\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n        default:\n            {\n                let description = '';\n                for(let i = 0; i < properties.length - 1; i++){\n                    description += `\\`${properties[i]}\\`, `;\n                }\n                description += `, and \\`${properties[properties.length - 1]}\\``;\n                return description;\n            }\n    }\n}\n\n//# sourceMappingURL=params.js.map","// Share the instance module in the next-shared layer\nimport { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with {\n    'turbopack-transition': 'next-shared'\n};\nexport { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage };\n\n//# sourceMappingURL=dynamic-access-async-storage.external.js.map","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"«nxt-icon»\" />\n}\n","'use client'\n\nimport { Suspense, use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layer；\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n"],"names":["React","useContext","useUntrackedPathname","HTTPAccessErrorStatus","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isHTTPAccessFallbackError","warnOnce","MissingSlotContext","HTTPAccessFallbackErrorBoundary","Component","componentDidCatch","process","env","NODE_ENV","props","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","getDerivedStateFromError","error","httpStatus","triggeredStatus","getDerivedStateFromProps","state","pathname","previousPathname","undefined","render","notFound","forbidden","unauthorized","children","errorComponents","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","constructor","HTTPAccessFallbackBoundary","hasErrorFallback","TemplateContext","RenderFromTemplateContext","InvariantError","ClientPageRoot","searchParams","params","promises","window","workAsyncStorage","require","clientSearchParams","clientParams","store","getStore","createSearchParamsFromClient","createParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient","ClientSegmentRoot","slots","promise","IconMark","Suspense","use","MetadataOutlet","digest","AsyncMetadataOutlet","fallback"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}